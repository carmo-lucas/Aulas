[
["index.html", "Aulas de R Introdução", " Aulas de R Lucas Chagas Lima do Carmo 2020-04-05 Introdução Para a primeira aula teremos que instalar R através do site https://cran.r-project.org/ e o programa RStudio que é um ambiente de desenvolvimento integrado (IDE) que facilita a o uso do R, ele pode ser baixado para o sistema operacional que você estiver usando neste link https://rstudio.com/products/rstudio/download/ Você deve instalar o R antes do RStudio. "],
["tipos-de-dados.html", "Aula 1 Tipos de Dados", " Aula 1 Tipos de Dados Para esta aula iremos apenas usar o console. Na configuração padrão do RStudio o console é o painel esquerdo-inferior. O console é onde você vai mandar os comandos para o R executar linha a linha. Para comandos mais complicados com várias linhas é mais interessante escrever um script. Para criar um script use o atalho Ctrl + Shift + N no Windows ou Cmd + Shift + N no MacOs. Primeiro iremos discutir o que são objetos e que tipos de objetos podemos criar ou importar para dentro do R. No R e em outras linguagens de programação existe o conceito de objeto. Um objeto pode ser um vetor ou uma matriz de valores numéricos. Pode ser uma tabela com várias linhas e colunas, pode ser uma fórmula também. O termo objeto é um termo genérico com as aplicações citadas e muitas outras. Para criar um objeto, usamos o operador &lt;-, por exemplo: objeto &lt;- 1000 Este objeto contém o valor 1000 então se você decidir imprimir (print()) este objeto o valor que aparecerá para voce é de 1000. Os objetos podem conter outros tipos de valores também, por exemplo frases: frase &lt;- &quot;The first soft snow: leaves of the awed jonquil bow low&quot; Se você tentar usar print(frase) o resultado vai ser o texto que foi atribuído a este objeto. Outro tipo de objeto são vetores (em outras linguagens de programação são chamados arrays), Vetores são objetos que contém vários valores numéricos ou de texto. vetor &lt;- c(0, 4, 3, 5, 6, 4, 2) print(vetor) [1] 0 4 3 5 6 4 2 Até agora foram usadas duas funções: print() e c(). Para você descobrir o que estas funções fazem você pode digitar ?print() ou ?c() no console e ver a definição e os argumentos que elas precisam. Iremos discutir funções mais pra frente mas é bom entender desde o início como achar as informações relevantes para que não se perca tempo. Boa parte de aprender R é pesquisar e ler a documentação das funções que existem no R nativo e nas outras extensões (libraries ou packages) do R que se pode baixar. Em R existem vários tipos de classes de dados mas nesta aula iremos apenas aprender 4 deles: Caracteres (strings): Podem ser letras individuais ou frases longas, são usados como variáveis categóricas para diferenciar os grupos nos seus dados ou para criar anotações em gráficos. Números (integers, numeric, complex): Existem diversas classes de números, podem ser inteiros, decimais ou complexos. Fatores categóricos (factors): Fatores podem ser comparados a strings quando aplicados à distinção entre variáveis categóricas porém uma vantagem é que eles são ordenados e podem possuir níveis, o que strings não possuem. Lógicos (TRUE, FALSE): Valores lógicos servem para avaliar se alguma expressão é verdadeira ou falsa. Um exemplo simples é verificar de 4 é igual a 5. 4 == 5 [1] FALSE 1000 &lt;= -23 [1] FALSE &quot;abc&quot; == &quot;bca&quot; [1] FALSE is.numeric(&quot;c&quot;) [1] FALSE Como imaginado, se tentamos avaliar as expressões acima, o resultado é FALSE, agora se tentamos outra expressão que seja verdadeira como as abaixo temos um retorno TRUE 2*10 == 20 [1] TRUE 30 &gt; 12 [1] TRUE &quot;string&quot; == &quot;string&quot; [1] TRUE is.numeric(99) [1] TRUE A função ìs.numeric() usada é entendida como a pergunta: “Esse objeto que eu estou te mostrando é numérico?”, se sim, a função retorna TRUE e se não, o retorno é FALSE. Para finalizar a primeira aula faremos alguns exercícios Pesquisem para que servem as funções rep() e seq(); Usem essas funções para criar 3 vetores de qualquer tipo: numérico, string, lógico, etc.; Pesquisem como criar uma matriz e criem uma matriz com o alfabeto como mostrado abaixo. [,1] [,2] [,3] [,4] [1,] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; [2,] &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; [3,] &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; [4,] &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; [5,] &quot;Q&quot; &quot;R&quot; &quot;S&quot; &quot;T&quot; [6,] &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; [7,] &quot;Y&quot; &quot;Z&quot; &quot;a&quot; &quot;b&quot; [8,] &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; [9,] &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; [10,] &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; [11,] &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; [12,] &quot;s&quot; &quot;t&quot; &quot;u&quot; &quot;v&quot; [13,] &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; "],
["extensões.html", "Aula 2 Extensões", " Aula 2 Extensões Uma forma de trabalhar com o R é usando extensões, comumente chamadas de “packages” ou “libraries”. Extensões são pacotes de funções escritas por outras pessoas cuja finalidade é facilitar algumas operações específicas por exemplo: eu gostaria de criar uma função que retorna a frase Meu nome é &lt;nome&gt; e tenho &lt;idade&gt; anos de idade&gt; onde seja substituido idade e nome pelos dados corretos. # Criando a função nome_idade &lt;- function(nome, idade) { return(paste(&quot;Meu nome é&quot;, nome, &quot;e tenho&quot;, idade, &quot;anos de idade&quot;)) } # Usando a função nome_idade(&quot;Gilson&quot;, 40) [1] &quot;Meu nome é Gilson e tenho 40 anos de idade&quot; Neste caso eu escrevi esta função simples para exemplificar, mas os pacotes podem ter muitas funções muito mais complexas que sejam mais difíceis de escrever. "],
["tidyverse.html", "2.1 tidyverse", " 2.1 tidyverse As extensões portanto são pacotes com funções que servem para ajudar a fazer algo específico. Os pacotes que gostaria de focar são os contidos na coleção tidyverse que contém os pacotes: ggplot2, dplyr, readr, tidyr,stringr ,forcats, purrr e tibble. Todos estes pacotes seguem a mesma filosofia de que os dados devem estar organizados de uma forma tidy descrita por Wickham (2014), ou seja: cada coluna é uma variável e cada linha uma observação. Cada um desses pacotes tem uma finalidade específica, com seus conjuntos de funções específicos. 2.1.1 dplyr Odplyr:: é um pacote que serve para manipular os dados no formato de dataframes através de operações de filtragem de linhas (filter()), colunas (select()), agrupamento dos dados de acordo com as variáveis categóricas (group_by()), resumir os dados usando summarise() e reordená-los usando arrange(). Existem cheat sheets que são as “colas” com as funções existentes para os pacotes mais usados e exemplos úteis. Cheat sheet dplyr. 2.1.2 tidyr O pacote tidyr:: é muito útil para organizar os dados da forma que o R e consequentemente os pacotes to tidyverse leiam melhor. As funções mais importantes neste pacote são a pivot_longer(), que substituiu gather() e pivot_wider() que substituiu spread(). Estas funções servem para transformar os dados de um formato “largo” para “longo” e vice-versa. Explicando visualmente é mais fácil de entender, portanto de acordo com o exemplo abaixo: # A tibble: 10 x 5 Pop. `2009` `2010` `2011` `2012` &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 a 1 3 54 536 2 b 3 5 3 63 3 c 5 2 6 5 4 d 7 6 2 2 5 e 3 3 4 3 6 f 67 2 7 4 7 g 3 5 3 5 8 h 7 2 5 6 9 i 8 64 7 7 10 j 4 6 8 7 Aqui temos uma tabela no formado “largo”, onde tenho uma coluna por ano. Não há nada de errado com essa formatação, mas usando as funções de base do R e as funções do conjunto tidyverse é mais fácil que transformemos esta tabela para o formato “longo” como no exemplo abaixo. long &lt;- wide %&gt;% tidyr::pivot_longer( cols = &quot;2009&quot;:&quot;2012&quot;, # Quais colunas quero mudar names_to = &quot;Ano&quot;, # Nome da variável que vai conter o nome das colunas values_to = &quot;Valor&quot;) # Nome da variável que vai conter os valores long # A tibble: 40 x 3 Pop. Ano Valor &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; 1 a 2009 1 2 a 2010 3 3 a 2011 54 4 a 2012 536 5 b 2009 3 6 b 2010 5 7 b 2011 3 8 b 2012 63 9 c 2009 5 10 c 2010 2 # … with 30 more rows O pacote tidyr contém outras funções para separar ou unir valores em colunas. Você pode achar mais informações sobre as funçõs no site do pacote. 2.1.3 readr O pacote readr serve para importar arquivos para dentro do ambiente do R. Este pacote funciona melhor com formatos de data retangular, ou seja, tabelas. As funções principais são: read_csv(): lê arquivos tipo .csv ou .txt com colunas separados por , e decimal como .. read_tsv(): lê arquivos de texto tipo .txt com colunas separadas por tabulação (\\t). read_delim(): com esta função, podem ser lidos arquivos de texto especificando o delimitador usando o argumento delim =, onde delim pode ser qualquer caractere. read_table(): lê arquivos de texto cujas colunas são separadas por espaços em branco. Outro pacote interessante para importar dados para o ambiente do R é ao pacote readxl:: para importar arquivos .xlsx direto do Excel ou o pacote googlesheets:: para importar dados armazenados no seu Google Drive. 2.1.4 stringr Este pacote serve para manipulação, adição, extração, ordenação de strings. Strings são classificadas como qualquer conjunto de caracteres, podendo constituir palavras ou frases ou qualquer sequência de caracteres. Este pacote é muito útil para extrair palavras específicas de textos ou para verificar se algum termo especificado está presente no texto estudado. Stringr Cheat Sheet 2.1.5 tibble tibbles são equivalentes a dataframes, são tabelas que contém dados. A diferença é que alguns tibbles respondem de forma diferente à algumas funções, por exemplo, a nossa tabela “longa” da seção 2.1.2 é uma tibble, portanto quando imprimimos ela no console apenas vemos as primeiras 10 linhas, porém quando tentamos imprimir como um data.frame todas as linhas (até o limite de 1000) são impressas, o que pode ser exagero quando se quer ter noção dos dados. # Imprimindo como tibble print(long) # A tibble: 40 x 3 Pop. Ano Valor &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; 1 a 2009 1 2 a 2010 3 3 a 2011 54 4 a 2012 536 5 b 2009 3 6 b 2010 5 7 b 2011 3 8 b 2012 63 9 c 2009 5 10 c 2010 2 # … with 30 more rows # Imprimindo como dataframe print(as.data.frame(long)) Pop. Ano Valor 1 a 2009 1 2 a 2010 3 3 a 2011 54 4 a 2012 536 5 b 2009 3 6 b 2010 5 7 b 2011 3 8 b 2012 63 9 c 2009 5 10 c 2010 2 11 c 2011 6 12 c 2012 5 13 d 2009 7 14 d 2010 6 15 d 2011 2 16 d 2012 2 17 e 2009 3 18 e 2010 3 19 e 2011 4 20 e 2012 3 21 f 2009 67 22 f 2010 2 23 f 2011 7 24 f 2012 4 25 g 2009 3 26 g 2010 5 27 g 2011 3 28 g 2012 5 29 h 2009 7 30 h 2010 2 31 h 2011 5 32 h 2012 6 33 i 2009 8 34 i 2010 64 35 i 2011 7 36 i 2012 7 37 j 2009 4 38 j 2010 6 39 j 2011 8 40 j 2012 7 Este pacote também permite que sejam criadas tabelas usando as funções tibble(), que funciona como data.frame() e tribble() que permite criar tabelas usando uma formatação mais intuitiva. # Função tibble tibble(x = 1:5, y = 1, z = x ^ 2 + y) # A tibble: 5 x 3 x y z &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1 1 2 2 2 1 5 3 3 1 10 4 4 1 17 5 5 1 26 # Função tribble tribble( ~x, ~y, ~z, &quot;a&quot;, 2, 3.6, &quot;b&quot;, 1, 8.5 ) # A tibble: 2 x 3 x y z &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 a 2 3.6 2 b 1 8.5 2.1.6 purrr O pacote purrr serve programação funcional, ou seja, aplicação de funções criadas tanto pelo usuário quanto pelos desenvolvedores em vários objetos ao mesmo tempo de forma programática. Este pacote será explorado mais a frente quando outros conhecimentos já estiverem sido consolidados. purrr Cheat Sheet 2.1.7 forcats Este pacote serve para manipulação e ordenação de dados do tipo factor, os fatores, também chamados variáveis categóricas. Pode ser muito útil ordenando variáveis para construção de gráficos, porém sua utilidade é bastante limitada. suas funções serão explicadas de acordo que se tornem úteis. 2.1.8 magrittr Este pacote contém alguns operadores que servem para tornar o código mais amigável a humanos. O operador principal é o pipe que serve para pegar um objeto ou o output de uma função e passá-la à proxima operação, por exemplo: long %&gt;% filter (Ano == \"2010\") onde eu filtro as linhas da tibble long onde o Ano é igual a 2010. Em outros termos, na sintaxe mais matemática se eu tenho g(f(x)) o equivalente com o pipe seria f(x) %&gt;% g() ou até x %&gt;% f() %&gt;% g(). É uma forma de colocar a ordem das operações mais legível para quem está escrevendo ou lendo o código. Além do pipe existem outros operadores que o pacote providencia que serão explorados a medida que forem necessários e utilizados. 2.1.9 ggplot2 O ggplot2por sí merece seu próprio capítulo e várias aulas, porém aqui irei colocar alguns links interessantes para quem estive interessado em ir aprendendo desde já. O capítulo Data Visualization e o capítulo Graphics for communication do livro R for Data Science e o Cheat Sheet um site com vários exemplos de gráficos criados com ggplot2 e outros pacotes, STHDA, outro site com exemplos para gráficos com R Cookbook for R e o livro do Hadley Wickham ggplot2: Elegant Graphics for Data Analysis. References "],
["operadores.html", "Aula 3 Operadores", " Aula 3 Operadores A grande maioria de linguagens de programação possui os mesmos operadores matemáticos porém com uma sintaxe diferente. No R temos operadores aritméticos e lógicos. Em R os operadores são vetorizados, o que significa que as operações serão feitas em todos os elementos de um vetor. Veja os exemplos. "],
["operadores-aritméticos.html", "3.1 Operadores aritméticos", " 3.1 Operadores aritméticos Operador Descrição + Adição - Subtração * Multiplicação / Divisão ^ ou ** Exponenciação x %% y Modulus (restante inteiro da divisão de x por y) x %/% y Divisão de número inteiro (5 %/% 2 = 2) 3.1.1 Exemplos x &lt;- 1:10 # adição 4 + 5 [1] 9 x + 5 [1] 6 7 8 9 10 11 12 13 14 15 # subtração 99 - 98 [1] 1 x - 99 [1] -98 -97 -96 -95 -94 -93 -92 -91 -90 -89 # multiplicação 3 * 3 [1] 9 3 * x [1] 3 6 9 12 15 18 21 24 27 30 # divisão 11 / 4 [1] 2.75 11 / x [1] 11.000000 5.500000 3.666667 2.750000 2.200000 1.833333 1.571429 1.375000 1.222222 [10] 1.100000 # exponenciação 2 ^ 3 [1] 8 2 ^ x [1] 2 4 8 16 32 64 128 256 512 1024 # modulus 9 %% 2 [1] 1 9 %% 4 [1] 1 x %% 4 [1] 1 2 3 0 1 2 3 0 1 2 # divisão por número inteiro 11 %/% 4 [1] 2 12 %/% 1.3 [1] 9 12 %/% x [1] 12 6 4 3 2 2 1 1 1 1 "],
["operadores-lógicos.html", "3.2 Operadores Lógicos", " 3.2 Operadores Lógicos Operador Descrição &gt; Maior que &gt;= Maior ou igual a &lt; Menor que &lt;= Menor ou igual a == Exatamente igual a != Não igual a !x Negação x | y x OU y x &amp; y x E y isTRUE(x) Testa se x é TRUE Estes operadores irão sempre retornar valores lógicos do tipo TRUE ou FALSE. 3.2.1 Exemplos # &gt; maior que 4 &gt; 5 [1] FALSE 4 &gt;= 5 [1] FALSE x &gt; 4 [1] FALSE FALSE FALSE FALSE TRUE TRUE TRUE TRUE TRUE TRUE # &lt; menor que 4 &lt; 5 [1] TRUE 4 &lt;= 5 [1] TRUE x &lt; 4 [1] TRUE TRUE TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE # == exatamente igual 4 == 5 [1] FALSE x == 4 [1] FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE # != não igual 4 != 5 [1] TRUE x != 4 [1] TRUE TRUE TRUE FALSE TRUE TRUE TRUE TRUE TRUE TRUE # ! negação 3 == !x [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE !3 == x [1] TRUE TRUE FALSE TRUE TRUE TRUE TRUE TRUE TRUE TRUE # | OU x &gt; 5 | x &gt; 8 [1] FALSE FALSE FALSE FALSE FALSE TRUE TRUE TRUE TRUE TRUE # &amp; E x &lt;= 8 &amp; x &gt; 5 [1] FALSE FALSE FALSE FALSE FALSE TRUE TRUE TRUE FALSE FALSE # isTRUE() isTRUE(x &lt;= 8 &amp; x &gt; 5) [1] FALSE isTRUE(4 &gt; 5) [1] FALSE isTRUE(4 == 4) [1] TRUE "],
["ggplot2-1.html", "Aula 4 ggplot2", " Aula 4 ggplot2 O ggplot2 é um pacote para visualização de dados que serve tanto para análise de dados exploratória quanto para criação de plots para publicação em revistas científicas. O termo ggplot vem de Grammar of Graphics, um conceito introduzido por Chambers et al. (1983) que significa gramática de gráficos, um modelo de construção de gráficos com componentes independentes que podem ser organizados de diversas formas. Este pacote facilita a produção de gráficos altamente customizados que podem ser gerados automaticamente usando o ambiente do R. O ggplot2 em si pode ser extendido com outros pacotes que ampliam suas funcionalidades porém a princípio iremos focar nas funcionalidades de base do ggplot2. References "],
["gramática-de-gráficos.html", "4.1 Gramática de Gráficos", " 4.1 Gramática de Gráficos De acordo com os conceitos implementados por Chambers et al. (1983) todos os plots são compostos dos seguintes elementos: Dados que se deseja visualizar e o mapeamento estético das variáveis. Por mapeamento estético entende-se como que os dados serão visualizados, seja por tamanho dos elementos gráficos, cor, forma etc. Camadas são compostas de elementos geométricos ou geom para abreviar. Estas camadas podem conter pontos ou linhas, polígonos ou transformações estatísticas ou stat, com o resumo estatístico das variáveis por exemplo, média, mediana, intervalos quartis etc. Escalas que podem ser atribuídas aos eixos do plot ou às cores e tamanho dos elementos. Escalas podem ser modificadas para mostrarem valores em distribuição logarítmica ou raiz quadrada e outras transformações. Sistema de Coordenadas usado, seja polar ou carteseano, incluindo as linhas do grid do plot ou até coordenadas para se criar um mapa. Subgrupos podem ser usados para dividir os dados de acordo com alguma variável categórica, para fins de comparação. São chamados de facets. Tema: o tema controla elementos do gráfico que não mudam a visualização dos dados, como paleta de cores, tipografia, cor de fundo, cores das linhas e outros elementos. Existem alguns pacotes desenvolvidos para modificar o tema com maior facilidade e alguns com temas prontos como o ggthemes::. O tema padrão do ggplot2 pode não se adequado para o uso em diversos ambientes acadêmicos portanto é importante aprender a customizar os gráficos especialmente para publicações em revistas científicas. References "],
["instalação.html", "4.2 Instalação", " 4.2 Instalação O ggplot2 é instalado quando se instala o tidyverse, porém se não se deseja instalar todos os pacotes do tidyverse apenas instale o ggplot2 usando: # install.packages(&quot;ggplot2&quot;) Para usar o ggplot2 é necessário importar as funções do pacote instalado para o ambiente do R através de: # Importar todos os pacotes do tidyverse library(tidyverse) # Importar apenas ggplot2 library(ggplot2) Apenas assim as fuções do ggplot2 poderão ser usadas no script ou no projeto. "],
["componentes-principais-dos-gráficos.html", "4.3 Componentes principais dos gráficos", " 4.3 Componentes principais dos gráficos Cada plot tem 3 componentes principais: dados; mapeamento estético; no mínimo uma camada que descreve como mostrar cada observação dos dados. Camadas são criadas através das funções geom_* ou stat_*. Um exemplo muito simples usando o dataframe mpg do pacote dplyr. ggplot(data = mpg, # Todo plot começa com a função ggplot() aes( # Mapeamentos estéticos devem ficar dentro desta função x = displ, # Variável mapeada no eixo x y = hwy) # Variável mapeada no eixo y ) + # + indica que vou adicionar uma camada geom_point() # Tipo de geometria usada para mostrar as observações Neste gráfico de dispersão especificamos os dados dos eixos x e y e definimos que queremos ver as observações como pontos usando a função geom_point() então suprimos os 3 requerimentos básicos para um plot: dados: mpg; mapeamento estético: displa no eixo x e altura no eixo y; camada: pontos. As escalas foram criadas automaticamente baseado nos valores máximos e mínimos das variáveis e o nome das variáveis foi colocado exatamente como está no dataframe. Algumas simplificações podem ser feitas no código, por exemplo: em geral não é necessário deixar implícito a especificação de qual variável vai no eixo x e qual no eixo y. Também não é necessário se deixar implícito o argumento data = portanto uma forma simplificada de escrever o mesmo código que resulta no mesmo gráfico é: ggplot(mpg, aes(displ, hwy)) + geom_point() "],
["cores-tamanhos-formas-e-outros-atributos-estéticos.html", "4.4 Cores, tamanhos, formas e outros atributos estéticos", " 4.4 Cores, tamanhos, formas e outros atributos estéticos No primeiro gráfico apenas usamos o mapeamentos estéticos x e y para definir em qual eixo as observações seriam colocadas, porém existem outras estéticas como tamanho (size), forma (shape) e cor (color, fill) que também podem ser mapeadas no gráfico de acordo com os valores das variáveis. Um exemplo é plotar os valores da variável classe como cores no gráfico: ggplot(mpg, aes(displ, hwy, color = class)) + geom_point() Assim começamos a procurar por relacionamentos nas variáveis. Podemos também usar o tamanho dos pontos como mapeamentos estéticos. ggplot(mpg, aes(displ, hwy, color = class, size = cty)) + geom_point() Veja que as legendas aparecem automaticamente ao lado direito, junto com as cores. Finalmente podemos usar a forma dos pontos para mapear outra variável. ggplot(mpg, aes(displ, hwy, color = class, size = cty, shape = drv)) + geom_point() Um erro comum é tentar especificar a cor do geom dentro da função aes() o que tem resultados completamente indesejados. p1 &lt;- ggplot(mpg, aes(displ, hwy)) + geom_point(aes(color = &quot;maroon&quot;)) p2 &lt;- ggplot(mpg, aes(displ, hwy)) + geom_point(color = &quot;maroon&quot;) # Para funcionar você deve usar o pacote patchwork p1 + p2 É importante lembrar que quando se inclui algum elemento estético dentro da função aes() os valores serão mapeados a uma escala estética portanto colocar um valor único, como um string irá produzir uma escala com valor único, não gerando o resultado esperado como mostrado no gráfico acima a esquerda. "],
["geoms.html", "4.5 Geoms", " 4.5 Geoms 4.5.1 Geoms individuais Estes geoms são os fundamentais para a construção de plots, podem ser por sí um gráfico completo ou podem compor gráficos mais complexos. Cada um destes geoms são bidimensionais e requerem estéticas de ambos x e y. Todos eles entendem color e size como sendo parâmetros de mapeamento estético e os geoms que contém área interna como geom_bar e geom_polygon também entendem o parametro fill como mapeamento. Estes geoms estarão listados abaixo: geom_area(): cria um plot de área que é um gráfico de linha com a área abaixo da linha preenchida. Dados agrupados são dispostos no gráfico sobrepostos. geom_bar(stat = \"identity\"): gráfico de barras, é necessário especificar o stat = \"identity\" porque o padrão do geom_bar é um plot de frequência, tornando-o essencialmente um gráfico unidimensional. Com a estatística definida como identity no eixo x ficam os valores especificados pela estética x e no eixo y os valores especificados pela estética y. geom_line(): gráfico de linhas que conecta os pontos na direção da esquerda para a direita, geom_path() funciona de forma similar porém conecta os pontos na ordem que estão dispostos os dados. Os mapeamentos estéticos que são aceitos por estes geoms são linetype (ou lty para abreviar), onde diferentes linhas serão geradas para cada grupo e group que é a especificação de dados agrupados sem ter efeito na visualização dentro do gráfico. geom_point(): gera um gráfico de dispersão, aceita o mapeamento estético shape que gera diferentes formatos de pontos dependendo do grupo. geom_text(): usado quando em vez de desenhar pontos nas coordenadas, desenhar texto, seja palavras ou letras. geom_polygon(): gera polígonos preenchidos onde cada vértice é uma linha no dataframe com as coordenadas de x e y em colunas separadas. É util para construção de mapas. geom_rect(), geom_tile() e geom_raster(): geram retângulos. Os parâmetros necessários para geom_rect() são as coordenadas máximas e mínimas das faces x e y sendo xmin, xmax, ymin e ymax. geom_tile() é exatamente o mesmo porém com x e y sendo as coordenadas do centro do retângulo e os parâmetros width e height como a largura e altura respectivamente. geom_raster() é usado caso o tamanho de todos os retângulos seja o mesmo para aumentar a velocidade da criação do gráfico. Cada um destes geoms será demonstrado nas figuras abaixo. Observe as semelhanças e diferenças dos eixos x e y, alguns extrapolam os valores estabelecidos pelos dados e podem estender os limítes dos eixos. df &lt;- data.frame ( x &lt;- c(1, 5, 9, 3.4), y &lt;- c(3, 6, 2, 5.4), label &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;) ) p &lt;- ggplot( df, aes(x, y, label = label)) + labs(x = NULL, y = NULL) + # esconde o nome dos eixos theme(plot.title = element_text(size = 12)) # diminui tamanho do texto p1 &lt;- p + geom_point() + ggtitle(&quot;ponto&quot;) p2 &lt;- p + geom_text() + ggtitle(&quot;texto&quot;) p3 &lt;- p + geom_bar(stat = &quot;identity&quot;) + ggtitle(&quot;barra&quot;) p4 &lt;- p + geom_tile() + ggtitle(&quot;raster&quot;) p1 + p2 + p3 + p4 p5 &lt;- p + geom_line() + ggtitle(&quot;linha&quot;) p6 &lt;- p + geom_area() + ggtitle(&quot;área&quot;) p7 &lt;- p + geom_path() + ggtitle(&quot;caminho&quot;) p8 &lt;- p + geom_polygon() + ggtitle(&quot;polígono&quot;) p5 + p6 + p7 + p8 4.5.2 Geoms coletivos Os geoms individuais criam objetos gráficos para cada observação ou linha da tabela contendo os dados, por exemplo, cada ponto de geom_point() representa uma linha de dados mas os geoms coletivos mostram várias observações, ou linhas, por elemento gráfico gerado. Isso pode ser o resultado de um resumo estatístico como um boxplot ou resultado de como os dados devem ser dispostos. Linhas e path estão no meio termo entre individuais e coletivos porque apesar de cada extremidade de uma linha ser apenas uma observação, o segmento é o conjunto de duas observações da tabela, ou seja, dois pontos. Para controlar o comportamento devemos usar a estética group. Por padrão, a estética group é mapeada para as variáveis discretas (ou categóricas) dos dados fornecidos à função ggplot() e na maioria dos casos o padrão é o suficiente para que os dados fiquem organizados no gráfico, porém quando não há variável discreta usada, é necessário que seja definido explicitamente um mapeamento agrupador dos dados. Há três casos comuns onde o padrão não é suficiente. Estes serão considerados abaixo. Para os exemplos a seguir será usado o dataset Oxboys do pacote nlme, que contém a altura e idade de 26 homens registrado em nove ocasiões diferentes. data(Oxboys, package = &quot;nlme&quot;) head(Oxboys) Grouped Data: height ~ age | Subject Subject age height Occasion 1 1 -1.0000 140.5 1 2 1 -0.7479 143.4 2 3 1 -0.4630 144.8 3 4 1 -0.1643 147.1 4 5 1 -0.0027 147.7 5 6 1 0.2466 150.2 6 4.5.2.1 Grupos múltiplos, uma estética Em várias situações é necessário separar os dados em grupos mas com a mesma estética. Em outras palavras: se deseja visualizar sujeitos distintos mas não é necessário identificá-los usando cores ou outros artifícios visuais. Isto é comum para estudos onde se quer ver a diferença entre vários sujeitos ao longo do tempo. Para exemplificar, abaixo na esquerda um plot com múltiplos grupos e uma estética e à direita múltiplos grupos e múltiplas estéticas: p1 &lt;- ggplot(Oxboys, aes(age, height, group = Subject)) + geom_point() + geom_line() + ggtitle(&quot;Uma estética&quot;) p2 &lt;- ggplot(Oxboys, aes(age, height, color = Subject)) + geom_point() + geom_line() + ggtitle(&quot;Múltiplas estéticas&quot;) p1 + p2 Neste caso o padrão de agrupamento não funciona e se não for definido explicitamente ou se for definido incorretamente o plot terá uma aparência de “lâmina de serra”. ggplot(Oxboys, aes(age, height)) + geom_point() + geom_line() Se um group não for definido por uma única variável e sim por combinação de várias é possível usar a função interaction() para combiná-las, por exemplo: aes(interaction(identidade_escola, identidade_aluno)). 4.5.3 Resumos estatísticos 4.5.4 Resolvendo overplotting 4.5.5 Anotações "],
["regressões.html", "Aula 5 Regressões", " Aula 5 Regressões Para criar modelos de regressão linear ou não linear no R precisamos usar uma tipo de objeto que tem a é da classe formula. Esta classe é usada em várias funções de base do R mas também no pacote de criação de gráficos ggplot2::. O que é essa classe formula: é um tipo de objeto que captura uma relacionamento simbólico entre variáveis, por exemplo: Tendo x como uma variável independente e y a variável dependente, para escrever \\(y\\) em função de \\(x\\) usamos a sytaxe y ~ x, onde o operador ~ separa as variáveis. Para modelos lineares esse é o mínimo que é necessário saber porém para mais informação sobre regressões com mais variáveis e modelos não lineares dê uma olhada neste link. "],
["regressões-lineares.html", "5.1 Regressões Lineares", " 5.1 Regressões Lineares No R para criar modelos lineares simples é usada a função lm(). Os principais argumentos são a formula e os dasos (data), você pode ler os outros argumentos usando rodando ?lm() no console. Então para montar um modelo de regressão limples é apenas necessário ter um dataframe com uma coluna com os valores de x e uma coluna com os valores de y. Iremos usar os dados do dataset mpg para criar exemplos. fit &lt;- lm(cty ~ displ, data = mpg) print(fit) Call: lm(formula = cty ~ displ, data = mpg) Coefficients: (Intercept) displ 25.99 -2.63 class(fit) [1] &quot;lm&quot; O resultado obtidos são o coeficientes de Intercept que é o coeficiente linear da reta e o outro coeficiente que tem o nome da variável é o coeficiente angular da reta. A função print() mostra apenas estes valores mas podemos acessar mais valores do modelo usando outras funções ou métodos. Observamos também que a classe do objeto fit que foi criado é lm, portanto qualquer função que tenha como acessar os dados contidos em objetos de classe lm podem ser usadas, por exemplo summary() summary(fit) Call: lm(formula = cty ~ displ, data = mpg) Residuals: Min 1Q Median 3Q Max -6.3109 -1.4695 -0.2566 1.1087 14.0064 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 25.9915 0.4821 53.91 &lt;2e-16 *** displ -2.6305 0.1302 -20.20 &lt;2e-16 *** --- Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Residual standard error: 2.567 on 232 degrees of freedom Multiple R-squared: 0.6376, Adjusted R-squared: 0.6361 F-statistic: 408.2 on 1 and 232 DF, p-value: &lt; 2.2e-16 Usando a função summary() obtemos vários valores que podem não ter muito significado quando o interesse é verificar o coeficiente de determinação (\\(R^2\\)) de um modelo, inclusive a função summary() retorna este valor mas também dados sobre a distribuição de residuais, erro dos coeficientes e outros valores estatísticos. Inclusive podemos visualizar estes dados usando a função plot() de base que consegue gerar vários gráficos apenas com o objeto de classe lm. plot(fit) Porém para o uso em questão isso não é extremamente relevante porque não estamos buscando avaliar a normalidade da distribuição e sim verificar se o modelo é adequado para uma curva de calibração. Neste caso iremos gerar dados simulados para calcular um novo modelo: # concentração de 0 a 20 conc &lt;- 0:20 # absorbância é igual a 2x a concentração mais um valor entre 0,5 e 1 abs = 2 * conc + runif(n = length(conc), min = 0.5, max = 2) calibracao &lt;- data.frame(conc, abs) calibracao conc abs 1 0 0.7174752 2 1 3.2408033 3 2 4.6132761 4 3 7.8638939 5 4 9.0502189 6 5 10.8727278 7 6 13.3089047 8 7 15.9768746 9 8 17.7511898 10 9 18.5300270 11 10 21.8916816 12 11 23.5065871 13 12 24.6986420 14 13 27.3138983 15 14 29.1334179 16 15 30.5413764 17 16 33.3345663 18 17 35.8559057 19 18 36.5348536 20 19 39.5679554 21 20 41.1626743 Com os dados gerados podemos gerar o modelo linear para os dados de calibracao. fit_calib &lt;- lm(abs ~ conc, data = calibracao) summary(fit_calib) Call: lm(formula = abs ~ conc, data = calibracao) Residuals: Min 1Q Median 3Q Max -0.70843 -0.45702 0.06249 0.32085 0.77563 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 1.17449 0.21186 5.544 2.4e-05 *** conc 2.00382 0.01812 110.570 &lt; 2e-16 *** --- Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Residual standard error: 0.5029 on 19 degrees of freedom Multiple R-squared: 0.9984, Adjusted R-squared: 0.9984 F-statistic: 1.223e+04 on 1 and 19 DF, p-value: &lt; 2.2e-16 Como esperado, o coeficiente angular é de aproximadamente 2 e o coeficiente linear que deveria ser 0 é de 1.1744914. Como todos os objetos, o objeto da classe lm possui uma estrutura. Podemos ver esta estrutura usando a função str(), que retorna a estrutura completa dos objetos, porém de uma forma não muito fácil de entender str(fit_calib) List of 12 $ coefficients : Named num [1:2] 1.17 2 ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;(Intercept)&quot; &quot;conc&quot; $ residuals : Named num [1:21] -0.457 0.0625 -0.5689 0.6779 -0.1396 ... ..- attr(*, &quot;names&quot;)= chr [1:21] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... $ effects : Named num [1:21] -97.2089 55.6038 -0.5126 0.7383 -0.0751 ... ..- attr(*, &quot;names&quot;)= chr [1:21] &quot;(Intercept)&quot; &quot;conc&quot; &quot;&quot; &quot;&quot; ... $ rank : int 2 $ fitted.values: Named num [1:21] 1.17 3.18 5.18 7.19 9.19 ... ..- attr(*, &quot;names&quot;)= chr [1:21] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... $ assign : int [1:2] 0 1 $ qr :List of 5 ..$ qr : num [1:21, 1:2] -4.583 0.218 0.218 0.218 0.218 ... .. ..- attr(*, &quot;dimnames&quot;)=List of 2 .. .. ..$ : chr [1:21] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... .. .. ..$ : chr [1:2] &quot;(Intercept)&quot; &quot;conc&quot; .. ..- attr(*, &quot;assign&quot;)= int [1:2] 0 1 ..$ qraux: num [1:2] 1.22 1.26 ..$ pivot: int [1:2] 1 2 ..$ tol : num 1e-07 ..$ rank : int 2 ..- attr(*, &quot;class&quot;)= chr &quot;qr&quot; $ df.residual : int 19 $ xlevels : Named list() $ call : language lm(formula = abs ~ conc, data = calibracao) $ terms :Classes &#39;terms&#39;, &#39;formula&#39; language abs ~ conc .. ..- attr(*, &quot;variables&quot;)= language list(abs, conc) .. ..- attr(*, &quot;factors&quot;)= int [1:2, 1] 0 1 .. .. ..- attr(*, &quot;dimnames&quot;)=List of 2 .. .. .. ..$ : chr [1:2] &quot;abs&quot; &quot;conc&quot; .. .. .. ..$ : chr &quot;conc&quot; .. ..- attr(*, &quot;term.labels&quot;)= chr &quot;conc&quot; .. ..- attr(*, &quot;order&quot;)= int 1 .. ..- attr(*, &quot;intercept&quot;)= int 1 .. ..- attr(*, &quot;response&quot;)= int 1 .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: R_GlobalEnv&gt; .. ..- attr(*, &quot;predvars&quot;)= language list(abs, conc) .. ..- attr(*, &quot;dataClasses&quot;)= Named chr [1:2] &quot;numeric&quot; &quot;numeric&quot; .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;abs&quot; &quot;conc&quot; $ model :&#39;data.frame&#39;: 21 obs. of 2 variables: ..$ abs : num [1:21] 0.717 3.241 4.613 7.864 9.05 ... ..$ conc: int [1:21] 0 1 2 3 4 5 6 7 8 9 ... ..- attr(*, &quot;terms&quot;)=Classes &#39;terms&#39;, &#39;formula&#39; language abs ~ conc .. .. ..- attr(*, &quot;variables&quot;)= language list(abs, conc) .. .. ..- attr(*, &quot;factors&quot;)= int [1:2, 1] 0 1 .. .. .. ..- attr(*, &quot;dimnames&quot;)=List of 2 .. .. .. .. ..$ : chr [1:2] &quot;abs&quot; &quot;conc&quot; .. .. .. .. ..$ : chr &quot;conc&quot; .. .. ..- attr(*, &quot;term.labels&quot;)= chr &quot;conc&quot; .. .. ..- attr(*, &quot;order&quot;)= int 1 .. .. ..- attr(*, &quot;intercept&quot;)= int 1 .. .. ..- attr(*, &quot;response&quot;)= int 1 .. .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: R_GlobalEnv&gt; .. .. ..- attr(*, &quot;predvars&quot;)= language list(abs, conc) .. .. ..- attr(*, &quot;dataClasses&quot;)= Named chr [1:2] &quot;numeric&quot; &quot;numeric&quot; .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;abs&quot; &quot;conc&quot; - attr(*, &quot;class&quot;)= chr &quot;lm&quot; Mas o que podemos observar é que o objeto é uma lista com 12 elementos então podemos acessar estes elementos através de seus índices ou de seus nomes. # coeficientes fit_calib$coefficients (Intercept) conc 1.174491 2.003822 # residuais fit_calib$residuals 1 2 3 4 5 6 7 8 -0.45701626 0.06248981 -0.56885936 0.67793638 -0.13956067 -0.32087385 0.11148104 0.77562884 9 10 11 12 13 14 15 16 0.54612202 -0.67886285 0.67896971 0.29005312 -0.52171402 0.08972027 -0.09458222 -0.69044578 17 18 19 20 21 0.09892211 0.61643944 -0.70843472 0.32084508 -0.08825809 E para acessar elementos específicos destas listas usamos os operadores [ ] # coeficiente linear (intercept) fit_calib$coefficients[1] (Intercept) 1.174491 # coeficiente angular fit_calib$coefficients[2] conc 2.003822 # valor do coeficiente linear (intercept) fit_calib$coefficients[[1]] [1] 1.174491 # valor do coeficiente angular fit_calib$coefficients[[2]] [1] 2.003822 # R quadrado summary(fit_calib)$r.squared [1] 0.9984483 Claro que parece muito complicado ter que fazer tudo isso para extrair alguns dados e mesmo assim, existem várias formas de extraí-los o que causa muita confusão, portanto iremos explorar alguns métodos para extraír estes dados do objeto lm(). 5.1.1 Método de função É fundamental em qualquer linguagem de programação que se saiba escrever funções que facilitem seu trabalho e deixem o código mais simples. Neste documento não estão escritas necessariamente as melhores funções que são mais eficientes mas aquelas que funcionam para o que é desejado. Na grande maioria das vezes é melhor escrever uma função rápido do que escrever uma função que funcione rápido. Otimização de código não é a nossa prioridade agora. Em outro capítulo será explorado a criação de funções melhor mas agora iremos apenas usar lógica para criar uma função que extraia os dados de coeficiente linear, angular, e \\(R^2\\) e coloque-os em um dataframe com os nomes e os valores usando a sintaxe já demonstrada. extrair &lt;- function(fit) { #fit é o argumento desta função # cria variável que contém coeficiente linear coef_lin &lt;- fit$coefficients[[1]] # cria variável que contém coeficiente angular coef_ang &lt;- fit$coefficients[[2]] # cria variável que contém r quadrado r_quadrado &lt;- summary(fit)$r.squared # cria dataframe com os dados em cada coluna tabela &lt;- data.frame( &quot;Coeficiente Linear&quot; = coef_lin, &quot;Coeficiente Angular&quot; = coef_ang, &quot;R quadrado&quot; = r_quadrado ) # pede para a função retornar o dataframe como output return(tabela) } # usando função nos dados de calibração extrair(fit_calib) Coeficiente.Linear Coeficiente.Angular R.quadrado 1 1.174491 2.003822 0.9984483 # usando função nos dados de mpg extrair(fit) Coeficiente.Linear Coeficiente.Angular R.quadrado 1 25.99147 -2.630482 0.6376405 Agora esta função pode ser usada sempe que se desejar extrair estes dados de um modelo linear criado com lm(). Não é a função mais robusta e alguns erros podem surgir quando tentando combinar ela com outras operações, mas para uma introdução funciona muito bem. 5.1.2 Método ggplot2 Um dos geoms do ggplot2 é o geom_smooth() que pode ser usado para plotar diversos modelos de regressão que não apenas lineares. É suplementado pela camada stat_smooth() que tem mais funcionalidade e mais customização. Para criar um gráfico com os pontos e a linha de regressão precisamos apenas dos dados de concentração e absorbância: ggplot(calibracao, aes( x = conc, y = abs )) + geom_point() + # method = lm indica que quero representar um modelo linear, # se = FALSE indica que não quero mostrar o erro padrão calculado geom_smooth(method = &quot;lm&quot;, se = FALSE, color = &quot;red&quot;, formula = &quot;y ~ x&quot;) Porém o ggplot2 não inclui nada que nos permita adicionar a equação com os coeficientes e o \\(R^2\\) automaticamente portanto temos que adicionar individualmente usando os dados extraídos com a nossa função extrair(). coefs &lt;- extrair(fit = fit_calib) coefs Coeficiente.Linear Coeficiente.Angular R.quadrado 1 1.174491 2.003822 0.9984483 ggplot(calibracao, aes( x = conc, y = abs )) + geom_smooth(method = &quot;lm&quot;, se = FALSE, color = &quot;red&quot;, formula = &quot;y ~ x&quot;) + geom_point() + annotate(geom = &quot;text&quot;, x = 5, # posição no eixo x y = 40, # posição no eixo y label = paste0(&quot;y = &quot;, coefs$Coeficiente.Angular, &quot;x + &quot;, coefs$Coeficiente.Linear)) + annotate(geom = &quot;text&quot;, x = 5, # posição no eixo x y = 36, # posição no eixo y label = paste0(&quot;R quadrado = &quot;, coefs$R.quadrado)) Claro que agora temos um problema de números significativos em excesso e de formatação da equação e do \\(R^2\\). Para resolver isso temos que usar a função format()para reduzir o número de dígitos significativos ou round() para arredondar e o argumento parse == TRUE para forçar o sobrescrito na camada de anotação. ggplot(calibracao, aes( x = conc, y = abs )) + geom_smooth(method = &quot;lm&quot;, se = FALSE, color = &quot;red&quot;, formula = &quot;y ~ x&quot;) + geom_point() + annotate(geom = &quot;text&quot;, x = 5, # posição no eixo x y = 40, # posição no eixo y label = paste0(&quot;y = &quot;, round(coefs$Coeficiente.Angular, digits = 3), &quot;x + &quot;, format(coefs$Coeficiente.Linear, digits = 2))) + annotate(geom = &quot;text&quot;, x = 5, # posição no eixo x y = 36, # posição no eixo y label = paste0(&quot;R^2 ==&quot;, round(coefs$R.quadrado, digits = 4)) , parse = TRUE) # força a renderização do texto como uma expressão matemática Claro que podemos escrever uma função usando as funções do ggplot para simplificar a construção destes gráficos, e esta pode ser uma alternativa viável mas outras pessoas já fizeram isso e publicaram pacotes justamente para atender esta necessidade. 5.1.3 Método ggpmisc O pacote ggpmisc é uma extensão do ggplot que adiciona funcionalidades sobre o mesmo. Com ele adicionar a equação e os coeficientes se torna muito mais simples. library(ggpmisc) ggplot(calibracao, aes( x = conc, y = abs )) + geom_smooth(method = &quot;lm&quot;, formula = &quot;y ~ x&quot;, se = FALSE, color = &quot;red&quot;) + geom_point() + # retirado da página do criador do pacote # https://github.com/cran/ggpmisc stat_poly_eq(aes(label = paste(..eq.label.., ..adj.rr.label.., sep = &quot;~~~~&quot;)), formula = &quot;y~x&quot;, parse = TRUE) Admito que não sei usar as funções deste pacote então recomendo que quem estiver lendo estas informaçõs busque outras fontes de conteúdo. A página do desenvolvedor contém várias informações e exemplos. 5.1.4 Método ggpubr Provavelmente este é o método mais simples para gerar gráficos de regressão linear para uma curva de calibração. O pacote é outra extensão do ggplot2 e foi feito para facilitar a construção de plots comuns no meio científico. A página possui vários exemplos e a documentação necessária para criação dos gráficos. O ggpubr é uma ferramenta que facilita bastante o uso do R para construção de gráficos, porém com algumas desvantagens e limitaçòes de customização. A sintaxe é um pouco diferente do ggplot mas similar o suficiente para não criar uma barreira para o usuário. library(ggpubr) ggpubr &lt;- ggscatter(calibracao, x = &quot;conc&quot;, y = &quot;abs&quot;, add = &quot;reg.line&quot;) + stat_cor(label.x = 5, label.y = 36) + stat_regline_equation(label.x = 5, label.y = 40) + ggtitle(&quot;Criado com ggpubr&quot;) ggpubr Alternativamente as funções do ggpubr podem ser usadas em plots criados com o ggplot2 porque os objetos criados pelos dois tem compatibilidades. gg &lt;- ggplot(calibracao, aes( x = conc, y = abs )) + geom_smooth(method = &quot;lm&quot;, se = FALSE, color = &quot;red&quot;, formula = &quot;y ~ x&quot;) + geom_point() + stat_cor(label.x = 5, label.y = 36) + stat_regline_equation(label.x = 5, label.y = 40) + ggtitle(&quot;Criado com ggplot2 + ggpubr&quot;) # usando patchwork ggpubr + gg Existe uma infinidade de formas de mostrar estes dados, o importante é achar a forma que melhor atende suas necessidades e que seja o mais fácil criar. "],
["references.html", "References", " References Chambers, John M, William S Cleveland, Beat Kleiner, and Paul A Tukey. 1983. “Graphical Methods for Data Analysis. Wadsworth &amp; Brooks.” Cole Statistics/Probability Series. Wickham, Hadley. 2014. “Tidy Data.” Journal of Statistical Software, Articles 59 (10): 1–23. https://doi.org/10.18637/jss.v059.i10. "]
]
