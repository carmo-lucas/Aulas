[
["index.html", "Aulas de R Introdução", " Aulas de R Lucas Chagas Lima do Carmo 2020-04-14 Introdução Para a primeira aula teremos que instalar R através do site https://cran.r-project.org/ e o programa RStudio que é um ambiente de desenvolvimento integrado (IDE) que facilita a o uso do R, ele pode ser baixado para o sistema operacional que você estiver usando neste link https://rstudio.com/products/rstudio/download/ Você deve instalar o R antes do RStudio. "],
["tipos-de-dados.html", "Aula 1 Tipos de Dados", " Aula 1 Tipos de Dados Para esta aula iremos apenas usar o console. Na configuração padrão do RStudio o console é o painel esquerdo-inferior. O console é onde você vai mandar os comandos para o R executar linha a linha. Para comandos mais complicados com várias linhas é mais interessante escrever um script. Para criar um script use o atalho Ctrl + Shift + N no Windows ou Cmd + Shift + N no MacOs. Primeiro iremos discutir o que são objetos e que tipos de objetos podemos criar ou importar para dentro do R. No R e em outras linguagens de programação existe o conceito de objeto. Um objeto pode ser um vetor ou uma matriz de valores numéricos. Pode ser uma tabela com várias linhas e colunas, pode ser uma fórmula também. O termo objeto é um termo genérico com as aplicações citadas e muitas outras. Para criar um objeto, usamos o operador &lt;-, por exemplo: objeto &lt;- 1000 Este objeto contém o valor 1000 então se você decidir imprimir (print()) este objeto o valor que aparecerá para voce é de 1000. Os objetos podem conter outros tipos de valores também, por exemplo frases: frase &lt;- &quot;The first soft snow: leaves of the awed jonquil bow low&quot; Se você tentar usar print(frase) o resultado vai ser o texto que foi atribuído a este objeto. Outro tipo de objeto são vetores (em outras linguagens de programação são chamados arrays), Vetores são objetos que contém vários valores numéricos ou de texto. vetor &lt;- c(0, 4, 3, 5, 6, 4, 2) print(vetor) [1] 0 4 3 5 6 4 2 Até agora foram usadas duas funções: print() e c(). Para você descobrir o que estas funções fazem você pode digitar ?print() ou ?c() no console e ver a definição e os argumentos que elas precisam. Iremos discutir funções mais pra frente mas é bom entender desde o início como achar as informações relevantes para que não se perca tempo. Boa parte de aprender R é pesquisar e ler a documentação das funções que existem no R nativo e nas outras extensões (libraries ou packages) do R que se pode baixar. Em R existem vários tipos de classes de dados mas nesta aula iremos apenas aprender 4 deles: Caracteres (strings): Podem ser letras individuais ou frases longas, são usados como variáveis categóricas para diferenciar os grupos nos seus dados ou para criar anotações em gráficos. Números (integers, numeric, complex): Existem diversas classes de números, podem ser inteiros, decimais ou complexos. Fatores categóricos (factors): Fatores podem ser comparados a strings quando aplicados à distinção entre variáveis categóricas porém uma vantagem é que eles são ordenados e podem possuir níveis, o que strings não possuem. Lógicos (TRUE, FALSE): Valores lógicos servem para avaliar se alguma expressão é verdadeira ou falsa. Um exemplo simples é verificar de 4 é igual a 5. 4 == 5 [1] FALSE 1000 &lt;= -23 [1] FALSE &quot;abc&quot; == &quot;bca&quot; [1] FALSE is.numeric(&quot;c&quot;) [1] FALSE Como imaginado, se tentamos avaliar as expressões acima, o resultado é FALSE, agora se tentamos outra expressão que seja verdadeira como as abaixo temos um retorno TRUE 2*10 == 20 [1] TRUE 30 &gt; 12 [1] TRUE &quot;string&quot; == &quot;string&quot; [1] TRUE is.numeric(99) [1] TRUE A função ìs.numeric() usada é entendida como a pergunta: “Esse objeto que eu estou te mostrando é numérico?”, se sim, a função retorna TRUE e se não, o retorno é FALSE. Para finalizar a primeira aula faremos alguns exercícios Pesquisem para que servem as funções rep() e seq(); Usem essas funções para criar 3 vetores de qualquer tipo: numérico, string, lógico, etc.; Pesquisem como criar uma matriz e criem uma matriz com o alfabeto como mostrado abaixo. [,1] [,2] [,3] [,4] [1,] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; [2,] &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; [3,] &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; [4,] &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; [5,] &quot;Q&quot; &quot;R&quot; &quot;S&quot; &quot;T&quot; [6,] &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; [7,] &quot;Y&quot; &quot;Z&quot; &quot;a&quot; &quot;b&quot; [8,] &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; [9,] &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; [10,] &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; [11,] &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; [12,] &quot;s&quot; &quot;t&quot; &quot;u&quot; &quot;v&quot; [13,] &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; "],
["tipos-de-objetos.html", "Aula 2 Tipos de objetos", " Aula 2 Tipos de objetos Na aula anterior foi discutido alguns tipos de dados que existem no R e como criar alguns objetos simples como vetores. Dados numéricos, lógicos e de texto podem ser usados para diversos objetivos porém é necessário que estejam devidamente organizados para facilitar operações. Agora iremos explorar como que estes dados podem estar organizados dentro dos objetos e quais são os tipos de obetos mais comuns no R. "],
["vetores.html", "2.1 Vetores", " 2.1 Vetores Vetores são os objetos mais comuns no R. Vetores suportam todos os tipos de dados do R sendo eles, decimais, inteiros, lógicos, complexos e texto (caracter). Um vetor é um tipo de objeto unidimensional que pode conter apenas um tipo de dado por exemplo: vetor &lt;- c(1.45, 4, 1L, &quot;a&quot;, &quot;99&quot;, TRUE, 2i+4) print(vetor) [1] &quot;1.45&quot; &quot;4&quot; &quot;1&quot; &quot;a&quot; &quot;99&quot; &quot;TRUE&quot; &quot;4+2i&quot; Por mais que se especifique números com decimal e números inteiros (representado por 1L), o vetor deve conter apenas um tipo de dado. Neste caso, todos os valores são convertidos para texto (character) porque todos os elementos do vetor podem ser convertidos, relativamente sem problema, para este tipo de dado. Pode-se verificar a classe deste vetor usando a função class() e observa-se que o resultado deve ser character. Vetores podem conter apenas um elemento ou podem ter número de elementos tão grande que extrapole a configuração de memória do seu computador. Pode-se fazer operações aritméticas entre vetores usando os operadores descritos no capítulo 3 e sua utilidade pode ser variada mas aqui será explicado as regras gerais das operações entre vetores. # Criando vetores v1 &lt;- c(0, 407, 1, 5) v2 &lt;- c(9, 12, 23, 2) # Adição de vetores v1 + v2 [1] 9 419 24 7 # Subtração de vetores v1 - v2 [1] -9 395 -22 3 # Multiplicação de vetores v1 * v2 [1] 0 4884 23 10 # Divisão de vetores v1 / v2 [1] 0.00000000 33.91666667 0.04347826 2.50000000 Em todos estes exemplos os vetores possuem o mesmo número de elementos, porém quando vetores possuem diferentes números de elementos, para operações aritméticas o vetor com menor número de elementos pode sofrer reciclagem de alguns elementos para que a operação seja completa. v3 &lt;- c(4, 5.6) # neste caso v3 age como se fosse c(4, 5.6, 4, 5.6) v1 + v3 [1] 4.0 412.6 5.0 10.6 v1 * v3 [1] 0.0 2279.2 4.0 28.0 Para organizar os elementos de vetores pode ser usado a função sort() que rearranja os elementos de um vetor na ordem crescente ou descrescente. v1 [1] 0 407 1 5 # Crescente sort(v1) [1] 0 1 5 407 # Decrescente sort(v1, decreasing = TRUE) [1] 407 5 1 0 "],
["matrizes.html", "2.2 Matrizes", " 2.2 Matrizes Matrizes no R são equivalmentes a matrizes matemáticas e os mesmos tipos de operações podem aritméticas podem ser usadas nelas. São objetos bidimensionais que funcionam de forma parecida aos vetores. Porém além de possuírem propriedades de matrizes matemáticas nas matrizes do R todos os tipos de dados podem estar contidos, não apenas números. \\[ matriz = \\begin{bmatrix} 0.4 &amp; 9 &amp; 24 \\\\ e &amp; \\pi &amp; 5^4 \\\\ C &amp; 6.023\\cdot10^{23} &amp; 0 \\end{bmatrix} \\] A matriz acima é equivalente ao objeto abaixo: matriz &lt;- matrix( c(0.4, 9, 24, &quot;e&quot;, pi, 5^4, &quot;C&quot;, 6.023*10^23, 0), nrow = 3, byrow = TRUE ) matriz [,1] [,2] [,3] [1,] &quot;0.4&quot; &quot;9&quot; &quot;24&quot; [2,] &quot;e&quot; &quot;3.14159265358979&quot; &quot;625&quot; [3,] &quot;C&quot; &quot;6.023e+23&quot; &quot;0&quot; Observa-se que assim como vetores, matrizes não suportam vários tipos de dados diferentes, então, quando elementos são incompatíveis, a priridade será a classe de texto, os caracteres. Todos os elementos da matriz serão convertidos para caracter se houver apenas um elemento deste tipo. Como matrizes são objetos bidimensionais os elementos podem ser específicados através do seu número de coluna e de linha, indicados quando se imprime a matriz usando print(). "],
["índices.html", "2.3 Índices", " 2.3 Índices O mesmo é válido para vetores, cada elemento de um vetor tem um número, ou seja um índice. O índice de matrizes e vetores pode ser acessado usando o operador []. Em vetores o primeiro elemento sempre terá índice 1 então para acessar o primeiro elemento do vetor v1 escreve-se v1[1] e o retorno é o valor do primeiro elemento de v1, neste caso 0. Dentro do [ ] podem ser usados vários operadores. Outro exemplo simples é querer extrair os 3 primeiros valores do vetor v1. Para fazer isso pode se usar v1[1:3] ou então excluir o quarto valor usando v[-4] que deve ser equivalente. Como é possível extrair o último valor do vetor sem saber quantos valores ele tem? No caso de vários vetores terem tamanhos diferentes como garantir que uma função sempre irá extrair o último valor? Podem ser usadas funções dentro do [ ] para se garantir isso, por exemplo: v1[(length(v1))] [1] 5 A função length() retorna o comprimento do vetor, como o último elemento deve ter o mesmo número do comprimento do vetor inteiro, desta forma se garante que o último elemento será extraído, neste caso o valor é de 5. Para matrizes os índices funcionam da mesma forma porém como matrizs são bidimensionais, cada elemento contém dois índices, um para a linha e um para a coluna. Por exemplo, para extrair o valor da primeira linha e primeira coluna da matriz criada anteriormente, escrevemos matriz[1, 1], dessa forma, tudo que vem antes da vírgula dentro do [ ] é o índice de qual linha e depois da vírgula o índice da coluna, escrevendo em termos gerais: matriz[row, col]. Portanto para se extrair o valor 9 da matriz de exemplo, se escreve: matriz[1,2]. Assim como em vetores, é possível usar funções dentro do [] para se retornar índices específicos porém pode ser que o comportamento não seja o esperado para vetores. Para extraír o último elemento de vetores usamos a função length() porém, em matrizes é neessário especificar qual coluna e qual linha deseja-se extrair o valor e length() funciona melhor com uma dimensão. Portanto é melhor usar outras funções como nrow() e ncol(). Logo, para escolher o elemento da última linha e última coluna pode-se escrever: matriz[nrow(matriz), ncol(matriz)] que é igual a 0. Em alguns alguns casos é necessário extrair todos os valores de uma linha ou todos os valores de uma coluna de uma matriz. Um atalho para se fazer isso é não especificar a coluna ou a linha, logo para selecionar apenas a segunda linha da matriz de exemplo, escreve-se: matriz[2, ]. Perceba que o espaço depois da vírgula fica vazio, dessa forma R entende que nenhuma coluna está sendo selecionada. Para selecionar todos os valores de uma coluna deixa-se o espaço em branco antes da vírgula, por exemplo matriz[ ,1]. Adicionalmente, para escolher a segunda e terceira coluna pode-se escrever matriz[ ,2:3]. O mesmo vale para escolher linhas. "],
["dataframes.html", "2.4 Dataframes", " 2.4 Dataframes Dataframes são objetos bidimensionais que apesar de se parecerem com matrizes, são bastante diferentes, em primeiro lugar, as colunas de dataframes devem ser nomeadas; em segundo lugar colunas diferentes podem conter tipos de dados diferentes. Dataframes são mais flexíveis que matrizes principalmente por poderem conter vários tipos de dados em suas colunas. Enquanto que matrizes convertem todos os dados para o tipo character quando há um elemento deste tipo, em dataframes podemos ter uma coluna com o tipo character ou tra com o tipo logical e outra com o tipo numeric sem problema nenhum. Para criar dataframes usa-se a função data.frame() que contém diversos vetores dentro, por exemplo: # df é abreviação para dataframe df &lt;- data.frame( Idade = c(round(runif(n = 10, min = 20, max = 30))), # aleatorio entre 20 e 30 Nome = c(&quot;Luc&quot;,&quot;Jon&quot;,&quot;Jean&quot;,&quot;Brie&quot;,&quot;Mary&quot;,&quot;Dave&quot;,&quot;Lee&quot;,&quot;Nat&quot;,&quot;Dani&quot;,&quot;Rob&quot;), # nomes Sexo = c(F,F,T,T,T,F,F,T,T,F) # vetor contendo valores lógicos que indicam sexo ) df Idade Nome Sexo 1 23 Luc FALSE 2 27 Jon FALSE 3 28 Jean TRUE 4 29 Brie TRUE 5 23 Mary TRUE 6 28 Dave FALSE 7 24 Lee FALSE 8 22 Nat TRUE 9 30 Dani TRUE 10 22 Rob FALSE # classe class(df) [1] &quot;data.frame&quot; # Estrutura str(df) &#39;data.frame&#39;: 10 obs. of 3 variables: $ Idade: num 23 27 28 29 23 28 24 22 30 22 $ Nome : Factor w/ 10 levels &quot;Brie&quot;,&quot;Dani&quot;,..: 7 5 4 1 8 3 6 9 2 10 $ Sexo : logi FALSE FALSE TRUE TRUE TRUE FALSE ... A limitação de dataframes é que todas as colunas devem conter o mesmo número de linhas mas em geral funcionam como tabelas. Este tipo de objeto que contém dados em um quadro é denominado de retângular. Dados no formato retângular são usados para construção de gráficos usando várias extensões do R e é o formato de dados que a maioria das pessoas está acostumado a trabalhar por causa do que já aprendeu em programas como o Excell. É possível adicionar novas colunas e linhas a dataframes apesar de adicionar colunas ser mais direto. Os índices de um dataframe funcionam exatamente como funcionam em matrizes porém como em dataframes todas as colunas são nomeadas, podemos usar seus nomes invés de seus números, então para escolher os dados da coluna usa-se o operador $, por exemplo: df$Idade retorna os valores da coluna Idade no formato de um vetor, portanto para adicionar uma coluna, é possível atribuir ao dataframe uma nova coluna da seguinte forma: # cria a variável Peso e adiciona ao objeto df df$Peso &lt;- c(runif(n = 10, min = 55, max = 100)) df Idade Nome Sexo Peso 1 23 Luc FALSE 75.63296 2 27 Jon FALSE 96.03934 3 28 Jean TRUE 87.67977 4 29 Brie TRUE 90.33336 5 23 Mary TRUE 57.85677 6 28 Dave FALSE 83.12961 7 24 Lee FALSE 76.68871 8 22 Nat TRUE 87.11510 9 30 Dani TRUE 85.12750 10 22 Rob FALSE 80.26446 # cria variável altura df$Altura &lt;- c(runif(n = 10, min = 159, max = 210)) df Idade Nome Sexo Peso Altura 1 23 Luc FALSE 75.63296 194.7757 2 27 Jon FALSE 96.03934 174.8089 3 28 Jean TRUE 87.67977 184.1880 4 29 Brie TRUE 90.33336 187.0005 5 23 Mary TRUE 57.85677 204.0996 6 28 Dave FALSE 83.12961 201.0042 7 24 Lee FALSE 76.68871 171.6910 8 22 Nat TRUE 87.11510 206.1561 9 30 Dani TRUE 85.12750 207.1469 10 22 Rob FALSE 80.26446 166.7024 Agora que temos as variáveis Altura e Peso (geradas aleatoriamente pela função ruinf()) podemos calcular o IMC de cada indivíduo com uma nova coluna chamada IMC: # cria coluna IMC usando valores de outras colunas df$IMC &lt;- df$Peso / (df$Altura/100)^2 # altura deve estar em metros df Idade Nome Sexo Peso Altura IMC 1 23 Luc FALSE 75.63296 194.7757 19.93616 2 27 Jon FALSE 96.03934 174.8089 31.42838 3 28 Jean TRUE 87.67977 184.1880 25.84502 4 29 Brie TRUE 90.33336 187.0005 25.83227 5 23 Mary TRUE 57.85677 204.0996 13.88897 6 28 Dave FALSE 83.12961 201.0042 20.57526 7 24 Lee FALSE 76.68871 171.6910 26.01576 8 22 Nat TRUE 87.11510 206.1561 20.49750 9 30 Dani TRUE 85.12750 207.1469 19.83870 10 22 Rob FALSE 80.26446 166.7024 28.88281 Para adicionar linhas é necessário ter outro dataframe com colunas com os mesmos nomes que o dataframe original e usar a função rbind(). Abaixo o exemplo: df2 &lt;- data.frame( Idade = c(34, 99), Nome = c(&quot;Huey&quot;,&quot;Zé&quot;), Sexo = c(FALSE, FALSE), Peso = c(NA, 100.49993), Altura = c(187, 176), IMC = c(NA, NA) ) df2 Idade Nome Sexo Peso Altura IMC 1 34 Huey FALSE NA 187 NA 2 99 Zé FALSE 100.4999 176 NA df_nova &lt;- rbind(df, df2) df_nova Idade Nome Sexo Peso Altura IMC 1 23 Luc FALSE 75.63296 194.7757 19.93616 2 27 Jon FALSE 96.03934 174.8089 31.42838 3 28 Jean TRUE 87.67977 184.1880 25.84502 4 29 Brie TRUE 90.33336 187.0005 25.83227 5 23 Mary TRUE 57.85677 204.0996 13.88897 6 28 Dave FALSE 83.12961 201.0042 20.57526 7 24 Lee FALSE 76.68871 171.6910 26.01576 8 22 Nat TRUE 87.11510 206.1561 20.49750 9 30 Dani TRUE 85.12750 207.1469 19.83870 10 22 Rob FALSE 80.26446 166.7024 28.88281 11 34 Huey FALSE NA 187.0000 NA 12 99 Zé FALSE 100.49993 176.0000 NA 2.4.1 Índices de dataframes Assim como matrizes os índices funcionam da mesma forma para dataframes com a diferença de que como as colunas possuem nomes, é possível usá-los para selecionar colunas então df[ ,\"Idade\"] é a mesma coisa que df[ ,1]. Outros operadores para seleção de linhas e colunas que não foi explorado anteriormente é o operador -. Por exemplo quando se quer selecionar todas as colunas exceto a coluna 2, é possível escrever df[ ,c(1,3,4,5,6)] ou muito mais fácil e rápido e simples df[ ,-2]. O mesmo vale para linhas de um dataframe e de uma matriz. O operador - indica subtração logo neste caso estou subtraindo a coluna 2 da minha seleção. Como nos casos anteriores, podem ser usadas funções para selecionar colunas e linhas específicas e um exercício para o leitor é descobrir como selecionar as linhas com número ímpar. Solução: df[c(TRUE,FALSE), ] Agora explique como isso funciona. "],
["listas.html", "2.5 Listas", " 2.5 Listas Listas são o tipo de objeto genéricos do R. Listas podem ter elementos que são vetores, matrizes e dataframes e não possuem formato retangular. Para explicar listas é mais fácil criar uma e deixar o leitor contemplar sua estrutura: lista &lt;- list( vetor_A = c(1, 4, 5.6, 8, 3, 1, 4.45), # vetor com números vetor_B = c(&quot;Frases com várias palavras&quot;, &quot;texto&quot;), # vetor com caracteres matriz_A = matrix( c(0,2,5,10), # valores da matriz ncol = 2, # número de colunas byrow = FALSE # preencher valores por linha? FALSE ), matriz_B = matrix( c(letters), # valores da matriz ncol = 3, # número de colunas byrow = TRUE # preencher por linha? TRUE ), dataframe_A = data.frame( Nome = c(&quot;Jack&quot;, &quot;Natalie&quot;, &quot;Margot&quot;), # coluna com nomes Sobrenome = c(&quot;Black&quot;, &quot;Portmann&quot;, &quot;Robbie&quot;), # coluna com sobrenome Nascimento = as.Date(c(&quot;1969-08-28&quot;,&quot;1981-06-09&quot;,&quot;1990-07-02&quot;)) # data de nascimento ) ) lista $vetor_A [1] 1.00 4.00 5.60 8.00 3.00 1.00 4.45 $vetor_B [1] &quot;Frases com várias palavras&quot; &quot;texto&quot; $matriz_A [,1] [,2] [1,] 0 5 [2,] 2 10 $matriz_B [,1] [,2] [,3] [1,] &quot;a&quot; &quot;b&quot; &quot;c&quot; [2,] &quot;d&quot; &quot;e&quot; &quot;f&quot; [3,] &quot;g&quot; &quot;h&quot; &quot;i&quot; [4,] &quot;j&quot; &quot;k&quot; &quot;l&quot; [5,] &quot;m&quot; &quot;n&quot; &quot;o&quot; [6,] &quot;p&quot; &quot;q&quot; &quot;r&quot; [7,] &quot;s&quot; &quot;t&quot; &quot;u&quot; [8,] &quot;v&quot; &quot;w&quot; &quot;x&quot; [9,] &quot;y&quot; &quot;z&quot; &quot;a&quot; $dataframe_A Nome Sobrenome Nascimento 1 Jack Black 1969-08-28 2 Natalie Portmann 1981-06-09 3 Margot Robbie 1990-07-02 # estrutura da lista str(lista) List of 5 $ vetor_A : num [1:7] 1 4 5.6 8 3 1 4.45 $ vetor_B : chr [1:2] &quot;Frases com várias palavras&quot; &quot;texto&quot; $ matriz_A : num [1:2, 1:2] 0 2 5 10 $ matriz_B : chr [1:9, 1:3] &quot;a&quot; &quot;d&quot; &quot;g&quot; &quot;j&quot; ... $ dataframe_A:&#39;data.frame&#39;: 3 obs. of 3 variables: ..$ Nome : Factor w/ 3 levels &quot;Jack&quot;,&quot;Margot&quot;,..: 1 3 2 ..$ Sobrenome : Factor w/ 3 levels &quot;Black&quot;,&quot;Portmann&quot;,..: 1 2 3 ..$ Nascimento: Date[1:3], format: &quot;1969-08-28&quot; &quot;1981-06-09&quot; &quot;1990-07-02&quot; Nesta lista temos então, vetores com números, vetores com texto, matrix com números e matrix com texto e um dataframe com 3 variáveis. Bastante complexo. 2.5.1 Índices de listas Listas tem estrutura com vários níveis, inclusive é possível criar uma lista dentro de outra lista com vários outros vetores matrizes, dataframes etc porém será focado em listas com apenas um nível. Como usar os índices? Fácil, usa-se os mesmos operadores que os de dataframe. Por exemplo: # selecionando o vetor_A lista$vetor_A [1] 1.00 4.00 5.60 8.00 3.00 1.00 4.45 # selecionando matriz_A lista$matriz_A [,1] [,2] [1,] 0 5 [2,] 2 10 # selecionando dataframe_A lista$dataframe_A Nome Sobrenome Nascimento 1 Jack Black 1969-08-28 2 Natalie Portmann 1981-06-09 3 Margot Robbie 1990-07-02 Mas como selecionar os elementos individuais do vetor_B, matriz_B e dataframe_A? Fácil, da mesma forma que se selecionada quando não estavam dentro da lista. # elemento 3 do vetor_B lista$vetor_A[3] [1] 5.6 # elemento na linha 6 e coluna 2 da matriz_B lista$matriz_B[6,2] [1] &quot;q&quot; # Nascimento da Margot Robbie lista$dataframe_A$Nascimento[3] [1] &quot;1990-07-02&quot; # ou lista$dataframe_A[3,3] [1] &quot;1990-07-02&quot; Listas são tipos de objetos muito úteis para o armazenamento de dados de forma legível tanto para computadores quanto para humanos. Este tipo de estrutura de dados é similar aos usados em bancos de dados não-tabulares. Essa estrutura é similar a arquivos JSON e dictionaries da linguagem python. É bastante útil para se armazenar vários dados de natureza diferente para amostras, por exemplo: Polimero_A &lt;- list( Nome = &quot;Polímero A&quot;, Fabricacao = as.Date(&quot;2019-09-24&quot;), Validade = &quot;3 meses&quot;, Curva_calibracao_HPLC = data.frame( Conc_Padrao = c(0.01, 0.05, 0.1, 0.5, 0.9, 1.0, 2, 3, 5, 10, 30, 100, 500), Abs = c(0, 0, 0, 0.1, 0.3, 0.9, 2, 4, 6, 29, 39, 50, 100) ), Descricao = list(Visual = &quot;pó amarelado&quot;, Odor = &quot;sem odor&quot;, Outros = &quot;higroscópico&quot;), Tratamento = c(&quot;Secagem por liofilização&quot;, &quot;Filtração com filtro n. 2&quot;), Estabilidade = data.frame( Dia = c(1:10), Separacao_fase = c(F, F, F, F, F, F, F, T, T, T), FaseO_por_FaseA = c(0, 0, 0, 0, 0, 0, 0, 0.4, 0.6, 0.9) ) ) Polimero_A $Nome [1] &quot;Polímero A&quot; $Fabricacao [1] &quot;2019-09-24&quot; $Validade [1] &quot;3 meses&quot; $Curva_calibracao_HPLC Conc_Padrao Abs 1 1e-02 0.0 2 5e-02 0.0 3 1e-01 0.0 4 5e-01 0.1 5 9e-01 0.3 6 1e+00 0.9 7 2e+00 2.0 8 3e+00 4.0 9 5e+00 6.0 10 1e+01 29.0 11 3e+01 39.0 12 1e+02 50.0 13 5e+02 100.0 $Descricao $Descricao$Visual [1] &quot;pó amarelado&quot; $Descricao$Odor [1] &quot;sem odor&quot; $Descricao$Outros [1] &quot;higroscópico&quot; $Tratamento [1] &quot;Secagem por liofilização&quot; &quot;Filtração com filtro n. 2&quot; $Estabilidade Dia Separacao_fase FaseO_por_FaseA 1 1 FALSE 0.0 2 2 FALSE 0.0 3 3 FALSE 0.0 4 4 FALSE 0.0 5 5 FALSE 0.0 6 6 FALSE 0.0 7 7 FALSE 0.0 8 8 TRUE 0.4 9 9 TRUE 0.6 10 10 TRUE 0.9 Este objeto contém todas as informações sobre a amostra desejadas e para acessar essas informações é apenas necessário usar os índices corretos. Para criar objetos JSON a partir de objetos em R a forma mais prática é usando o pacote jsonlite. Assim se encerra a aula de tipos de objetos e índices. Esses exemplos são muito simples mas podem ajudar a enfrentar tarefas de extração de objetos muito mais complexos criados pelas funções do R. "],
["operadores.html", "Aula 3 Operadores", " Aula 3 Operadores A grande maioria de linguagens de programação possui os mesmos operadores matemáticos porém com uma sintaxe diferente. No R temos operadores aritméticos e lógicos. Em R os operadores são vetorizados, o que significa que as operações serão feitas em todos os elementos de um vetor. Veja os exemplos. "],
["operadores-aritméticos.html", "3.1 Operadores aritméticos", " 3.1 Operadores aritméticos Operador Descrição + Adição - Subtração * Multiplicação / Divisão ^ ou ** Exponenciação x %% y Modulus (restante inteiro da divisão de x por y) x %/% y Divisão de número inteiro (5 %/% 2 = 2) 3.1.1 Exemplos x &lt;- 1:10 # adição 4 + 5 [1] 9 x + 5 [1] 6 7 8 9 10 11 12 13 14 15 # subtração 99 - 98 [1] 1 x - 99 [1] -98 -97 -96 -95 -94 -93 -92 -91 -90 -89 # multiplicação 3 * 3 [1] 9 3 * x [1] 3 6 9 12 15 18 21 24 27 30 # divisão 11 / 4 [1] 2.75 11 / x [1] 11.000000 5.500000 3.666667 2.750000 2.200000 1.833333 1.571429 1.375000 1.222222 [10] 1.100000 # exponenciação 2 ^ 3 [1] 8 2 ^ x [1] 2 4 8 16 32 64 128 256 512 1024 # modulus 9 %% 2 [1] 1 9 %% 4 [1] 1 x %% 4 [1] 1 2 3 0 1 2 3 0 1 2 # divisão por número inteiro 11 %/% 4 [1] 2 12 %/% 1.3 [1] 9 12 %/% x [1] 12 6 4 3 2 2 1 1 1 1 "],
["operadores-lógicos.html", "3.2 Operadores Lógicos", " 3.2 Operadores Lógicos Operador Descrição &gt; Maior que &gt;= Maior ou igual a &lt; Menor que &lt;= Menor ou igual a == Exatamente igual a != Não igual a !x Negação x | y x OU y x &amp; y x E y isTRUE(x) Testa se x é TRUE Estes operadores irão sempre retornar valores lógicos do tipo TRUE ou FALSE. 3.2.1 Exemplos # &gt; maior que 4 &gt; 5 [1] FALSE 4 &gt;= 5 [1] FALSE x &gt; 4 [1] FALSE FALSE FALSE FALSE TRUE TRUE TRUE TRUE TRUE TRUE # &lt; menor que 4 &lt; 5 [1] TRUE 4 &lt;= 5 [1] TRUE x &lt; 4 [1] TRUE TRUE TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE # == exatamente igual 4 == 5 [1] FALSE x == 4 [1] FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE # != não igual 4 != 5 [1] TRUE x != 4 [1] TRUE TRUE TRUE FALSE TRUE TRUE TRUE TRUE TRUE TRUE # ! negação 3 == !x [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE !3 == x [1] TRUE TRUE FALSE TRUE TRUE TRUE TRUE TRUE TRUE TRUE # | OU x &gt; 5 | x &gt; 8 [1] FALSE FALSE FALSE FALSE FALSE TRUE TRUE TRUE TRUE TRUE # &amp; E x &lt;= 8 &amp; x &gt; 5 [1] FALSE FALSE FALSE FALSE FALSE TRUE TRUE TRUE FALSE FALSE # isTRUE() isTRUE(x &lt;= 8 &amp; x &gt; 5) [1] FALSE isTRUE(4 &gt; 5) [1] FALSE isTRUE(4 == 4) [1] TRUE "],
["extensões.html", "Aula 4 Extensões", " Aula 4 Extensões Uma forma de trabalhar com o R é usando extensões, comumente chamadas de “packages” ou “libraries”. Extensões são pacotes de funções escritas por outras pessoas cuja finalidade é facilitar algumas operações específicas por exemplo: eu gostaria de criar uma função que retorna a frase Meu nome é &lt;nome&gt; e tenho &lt;idade&gt; anos de idade&gt; onde seja substituido idade e nome pelos dados corretos. # Criando a função nome_idade &lt;- function(nome, idade) { return(paste(&quot;Meu nome é&quot;, nome, &quot;e tenho&quot;, idade, &quot;anos de idade&quot;)) } # Usando a função nome_idade(&quot;Gilson&quot;, 40) [1] &quot;Meu nome é Gilson e tenho 40 anos de idade&quot; Neste caso eu escrevi esta função simples para exemplificar, mas os pacotes podem ter muitas funções muito mais complexas que sejam mais difíceis de escrever. "],
["tidyverse.html", "4.1 tidyverse", " 4.1 tidyverse As extensões portanto são pacotes com funções que servem para ajudar a fazer algo específico. Os pacotes que gostaria de focar são os contidos na coleção tidyverse que contém os pacotes: ggplot2, dplyr, readr, tidyr,stringr ,forcats, purrr e tibble. Todos estes pacotes seguem a mesma filosofia de que os dados devem estar organizados de uma forma tidy descrita por Wickham (2014), ou seja: cada coluna é uma variável e cada linha uma observação. Cada um desses pacotes tem uma finalidade específica, com seus conjuntos de funções específicos. 4.1.1 dplyr Odplyr:: é um pacote que serve para manipular os dados no formato de dataframes através de operações de filtragem de linhas (filter()), colunas (select()), agrupamento dos dados de acordo com as variáveis categóricas (group_by()), resumir os dados usando summarise() e reordená-los usando arrange(). Existem cheat sheets que são as “colas” com as funções existentes para os pacotes mais usados e exemplos úteis. Cheat sheet dplyr. 4.1.2 tidyr O pacote tidyr:: é muito útil para organizar os dados da forma que o R e consequentemente os pacotes to tidyverse leiam melhor. As funções mais importantes neste pacote são a pivot_longer(), que substituiu gather() e pivot_wider() que substituiu spread(). Estas funções servem para transformar os dados de um formato “largo” para “longo” e vice-versa. Explicando visualmente é mais fácil de entender, portanto de acordo com o exemplo abaixo: # A tibble: 10 x 5 Pop. `2009` `2010` `2011` `2012` &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 a 1 3 54 536 2 b 3 5 3 63 3 c 5 2 6 5 4 d 7 6 2 2 5 e 3 3 4 3 6 f 67 2 7 4 7 g 3 5 3 5 8 h 7 2 5 6 9 i 8 64 7 7 10 j 4 6 8 7 Aqui temos uma tabela no formado “largo”, onde tenho uma coluna por ano. Não há nada de errado com essa formatação, mas usando as funções de base do R e as funções do conjunto tidyverse é mais fácil que transformemos esta tabela para o formato “longo” como no exemplo abaixo. long &lt;- wide %&gt;% tidyr::pivot_longer( cols = &quot;2009&quot;:&quot;2012&quot;, # Quais colunas quero mudar names_to = &quot;Ano&quot;, # Nome da variável que vai conter o nome das colunas values_to = &quot;Valor&quot;) # Nome da variável que vai conter os valores long # A tibble: 40 x 3 Pop. Ano Valor &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; 1 a 2009 1 2 a 2010 3 3 a 2011 54 4 a 2012 536 5 b 2009 3 6 b 2010 5 7 b 2011 3 8 b 2012 63 9 c 2009 5 10 c 2010 2 # … with 30 more rows O pacote tidyr contém outras funções para separar ou unir valores em colunas. Você pode achar mais informações sobre as funçõs no site do pacote. 4.1.3 readr O pacote readr serve para importar arquivos para dentro do ambiente do R. Este pacote funciona melhor com formatos de data retangular, ou seja, tabelas. As funções principais são: read_csv(): lê arquivos tipo .csv ou .txt com colunas separados por , e decimal como .. read_tsv(): lê arquivos de texto tipo .txt com colunas separadas por tabulação (\\t). read_delim(): com esta função, podem ser lidos arquivos de texto especificando o delimitador usando o argumento delim =, onde delim pode ser qualquer caractere. read_table(): lê arquivos de texto cujas colunas são separadas por espaços em branco. Outro pacote interessante para importar dados para o ambiente do R é ao pacote readxl:: para importar arquivos .xlsx direto do Excel ou o pacote googlesheets:: para importar dados armazenados no seu Google Drive. 4.1.4 stringr Este pacote serve para manipulação, adição, extração, ordenação de strings. Strings são classificadas como qualquer conjunto de caracteres, podendo constituir palavras ou frases ou qualquer sequência de caracteres. Este pacote é muito útil para extrair palavras específicas de textos ou para verificar se algum termo especificado está presente no texto estudado. Stringr Cheat Sheet 4.1.5 tibble tibbles são equivalentes a dataframes, são tabelas que contém dados. A diferença é que alguns tibbles respondem de forma diferente à algumas funções, por exemplo, a nossa tabela “longa” da seção 4.1.2 é uma tibble, portanto quando imprimimos ela no console apenas vemos as primeiras 10 linhas, porém quando tentamos imprimir como um data.frame todas as linhas (até o limite de 1000) são impressas, o que pode ser exagero quando se quer ter noção dos dados. # Imprimindo como tibble print(long) # A tibble: 40 x 3 Pop. Ano Valor &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; 1 a 2009 1 2 a 2010 3 3 a 2011 54 4 a 2012 536 5 b 2009 3 6 b 2010 5 7 b 2011 3 8 b 2012 63 9 c 2009 5 10 c 2010 2 # … with 30 more rows # Imprimindo como dataframe print(as.data.frame(long)) Pop. Ano Valor 1 a 2009 1 2 a 2010 3 3 a 2011 54 4 a 2012 536 5 b 2009 3 6 b 2010 5 7 b 2011 3 8 b 2012 63 9 c 2009 5 10 c 2010 2 11 c 2011 6 12 c 2012 5 13 d 2009 7 14 d 2010 6 15 d 2011 2 16 d 2012 2 17 e 2009 3 18 e 2010 3 19 e 2011 4 20 e 2012 3 21 f 2009 67 22 f 2010 2 23 f 2011 7 24 f 2012 4 25 g 2009 3 26 g 2010 5 27 g 2011 3 28 g 2012 5 29 h 2009 7 30 h 2010 2 31 h 2011 5 32 h 2012 6 33 i 2009 8 34 i 2010 64 35 i 2011 7 36 i 2012 7 37 j 2009 4 38 j 2010 6 39 j 2011 8 40 j 2012 7 Este pacote também permite que sejam criadas tabelas usando as funções tibble(), que funciona como data.frame() e tribble() que permite criar tabelas usando uma formatação mais intuitiva. # Função tibble tibble(x = 1:5, y = 1, z = x ^ 2 + y) # A tibble: 5 x 3 x y z &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1 1 2 2 2 1 5 3 3 1 10 4 4 1 17 5 5 1 26 # Função tribble tribble( ~x, ~y, ~z, &quot;a&quot;, 2, 3.6, &quot;b&quot;, 1, 8.5 ) # A tibble: 2 x 3 x y z &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 a 2 3.6 2 b 1 8.5 4.1.6 purrr O pacote purrr serve programação funcional, ou seja, aplicação de funções criadas tanto pelo usuário quanto pelos desenvolvedores em vários objetos ao mesmo tempo de forma programática. Este pacote será explorado mais a frente quando outros conhecimentos já estiverem sido consolidados. purrr Cheat Sheet 4.1.7 forcats Este pacote serve para manipulação e ordenação de dados do tipo factor, os fatores, também chamados variáveis categóricas. Pode ser muito útil ordenando variáveis para construção de gráficos, porém sua utilidade é bastante limitada. suas funções serão explicadas de acordo que se tornem úteis. 4.1.8 magrittr Este pacote contém alguns operadores que servem para tornar o código mais amigável a humanos. O operador principal é o pipe que serve para pegar um objeto ou o output de uma função e passá-la à proxima operação, por exemplo: long %&gt;% filter (Ano == \"2010\") onde eu filtro as linhas da tibble long onde o Ano é igual a 2010. Em outros termos, na sintaxe mais matemática se eu tenho g(f(x)) o equivalente com o pipe seria f(x) %&gt;% g() ou até x %&gt;% f() %&gt;% g(). É uma forma de colocar a ordem das operações mais legível para quem está escrevendo ou lendo o código. Além do pipe existem outros operadores que o pacote providencia que serão explorados a medida que forem necessários e utilizados. 4.1.9 ggplot2 O ggplot2por sí merece seu próprio capítulo e várias aulas, porém aqui irei colocar alguns links interessantes para quem estive interessado em ir aprendendo desde já. O capítulo Data Visualization e o capítulo Graphics for communication do livro R for Data Science e o Cheat Sheet um site com vários exemplos de gráficos criados com ggplot2 e outros pacotes, STHDA, outro site com exemplos para gráficos com R Cookbook for R e o livro do Hadley Wickham ggplot2: Elegant Graphics for Data Analysis. References "],
["ggplot2-1.html", "Aula 5 ggplot2", " Aula 5 ggplot2 O ggplot2 é um pacote para visualização de dados que serve tanto para análise de dados exploratória quanto para criação de plots para publicação em revistas científicas. O termo ggplot vem de Grammar of Graphics, um conceito introduzido por Chambers et al. (1983) que significa gramática de gráficos, um modelo de construção de gráficos com componentes independentes que podem ser organizados de diversas formas. Este pacote facilita a produção de gráficos altamente customizados que podem ser gerados automaticamente usando o ambiente do R. O ggplot2 em si pode ser extendido com outros pacotes que ampliam suas funcionalidades porém a princípio iremos focar nas funcionalidades de base do ggplot2. References "],
["gramática-de-gráficos.html", "5.1 Gramática de Gráficos", " 5.1 Gramática de Gráficos De acordo com os conceitos implementados por Chambers et al. (1983) todos os plots são compostos dos seguintes elementos: Dados que se deseja visualizar e o mapeamento estético das variáveis. Por mapeamento estético entende-se como que os dados serão visualizados, seja por tamanho dos elementos gráficos, cor, forma etc. Camadas são compostas de elementos geométricos ou geom para abreviar. Estas camadas podem conter pontos ou linhas, polígonos ou transformações estatísticas ou stat, com o resumo estatístico das variáveis por exemplo, média, mediana, intervalos quartis etc. Escalas que podem ser atribuídas aos eixos do plot ou às cores e tamanho dos elementos. Escalas podem ser modificadas para mostrarem valores em distribuição logarítmica ou raiz quadrada e outras transformações. Sistema de Coordenadas usado, seja polar ou carteseano, incluindo as linhas do grid do plot ou até coordenadas para se criar um mapa. Subgrupos podem ser usados para dividir os dados de acordo com alguma variável categórica, para fins de comparação. São chamados de facets. Tema: o tema controla elementos do gráfico que não mudam a visualização dos dados, como paleta de cores, tipografia, cor de fundo, cores das linhas e outros elementos. Existem alguns pacotes desenvolvidos para modificar o tema com maior facilidade e alguns com temas prontos como o ggthemes::. O tema padrão do ggplot2 pode não se adequado para o uso em diversos ambientes acadêmicos portanto é importante aprender a customizar os gráficos especialmente para publicações em revistas científicas. References "],
["instalação.html", "5.2 Instalação", " 5.2 Instalação O ggplot2 é instalado quando se instala o tidyverse, porém se não se deseja instalar todos os pacotes do tidyverse apenas instale o ggplot2 usando: # install.packages(&quot;ggplot2&quot;) Para usar o ggplot2 é necessário importar as funções do pacote instalado para o ambiente do R através de: # Importar todos os pacotes do tidyverse library(tidyverse) # Importar apenas ggplot2 library(ggplot2) Apenas assim as fuções do ggplot2 poderão ser usadas no script ou no projeto. "],
["componentes-principais-dos-gráficos.html", "5.3 Componentes principais dos gráficos", " 5.3 Componentes principais dos gráficos Cada plot tem 3 componentes principais: dados; mapeamento estético; no mínimo uma camada que descreve como mostrar cada observação dos dados. Camadas são criadas através das funções geom_* ou stat_*. Um exemplo muito simples usando o dataframe mpg do pacote dplyr. ggplot(data = mpg, # Todo plot começa com a função ggplot() aes( # Mapeamentos estéticos devem ficar dentro desta função x = displ, # Variável mapeada no eixo x y = hwy) # Variável mapeada no eixo y ) + # + indica que vou adicionar uma camada geom_point() # Tipo de geometria usada para mostrar as observações Neste gráfico de dispersão especificamos os dados dos eixos x e y e definimos que queremos ver as observações como pontos usando a função geom_point() então suprimos os 3 requerimentos básicos para um plot: dados: mpg; mapeamento estético: displa no eixo x e altura no eixo y; camada: pontos. As escalas foram criadas automaticamente baseado nos valores máximos e mínimos das variáveis e o nome das variáveis foi colocado exatamente como está no dataframe. Algumas simplificações podem ser feitas no código, por exemplo: em geral não é necessário deixar implícito a especificação de qual variável vai no eixo x e qual no eixo y. Também não é necessário se deixar implícito o argumento data = portanto uma forma simplificada de escrever o mesmo código que resulta no mesmo gráfico é: ggplot(mpg, aes(displ, hwy)) + geom_point() "],
["cores-tamanhos-formas-e-outros-atributos-estéticos.html", "5.4 Cores, tamanhos, formas e outros atributos estéticos", " 5.4 Cores, tamanhos, formas e outros atributos estéticos No primeiro gráfico apenas usamos o mapeamentos estéticos x e y para definir em qual eixo as observações seriam colocadas, porém existem outras estéticas como tamanho (size), forma (shape) e cor (color, fill) que também podem ser mapeadas no gráfico de acordo com os valores das variáveis. Um exemplo é plotar os valores da variável classe como cores no gráfico: ggplot(mpg, aes(displ, hwy, color = class)) + geom_point() Assim começamos a procurar por relacionamentos nas variáveis. Podemos também usar o tamanho dos pontos como mapeamentos estéticos. ggplot(mpg, aes(displ, hwy, color = class, size = cty)) + geom_point() Veja que as legendas aparecem automaticamente ao lado direito, junto com as cores. Finalmente podemos usar a forma dos pontos para mapear outra variável. ggplot(mpg, aes(displ, hwy, color = class, size = cty, shape = drv)) + geom_point() Um erro comum é tentar especificar a cor do geom dentro da função aes() o que tem resultados completamente indesejados. p1 &lt;- ggplot(mpg, aes(displ, hwy)) + geom_point(aes(color = &quot;maroon&quot;)) p2 &lt;- ggplot(mpg, aes(displ, hwy)) + geom_point(color = &quot;maroon&quot;) # Para funcionar você deve usar o pacote patchwork p1 + p2 É importante lembrar que quando se inclui algum elemento estético dentro da função aes() os valores serão mapeados a uma escala estética portanto colocar um valor único, como um string irá produzir uma escala com valor único, não gerando o resultado esperado como mostrado no gráfico acima a esquerda. "],
["geoms.html", "5.5 Geoms", " 5.5 Geoms 5.5.1 Geoms individuais Estes geoms são os fundamentais para a construção de plots, podem ser por sí um gráfico completo ou podem compor gráficos mais complexos. Cada um destes geoms são bidimensionais e requerem estéticas de ambos x e y. Todos eles entendem color e size como sendo parâmetros de mapeamento estético e os geoms que contém área interna como geom_bar e geom_polygon também entendem o parametro fill como mapeamento. Estes geoms estarão listados abaixo: geom_area(): cria um plot de área que é um gráfico de linha com a área abaixo da linha preenchida. Dados agrupados são dispostos no gráfico sobrepostos. geom_bar(stat = \"identity\"): gráfico de barras, é necessário especificar o stat = \"identity\" porque o padrão do geom_bar é um plot de frequência, tornando-o essencialmente um gráfico unidimensional. Com a estatística definida como identity no eixo x ficam os valores especificados pela estética x e no eixo y os valores especificados pela estética y. geom_line(): gráfico de linhas que conecta os pontos na direção da esquerda para a direita, geom_path() funciona de forma similar porém conecta os pontos na ordem que estão dispostos os dados. Os mapeamentos estéticos que são aceitos por estes geoms são linetype (ou lty para abreviar), onde diferentes linhas serão geradas para cada grupo e group que é a especificação de dados agrupados sem ter efeito na visualização dentro do gráfico. geom_point(): gera um gráfico de dispersão, aceita o mapeamento estético shape que gera diferentes formatos de pontos dependendo do grupo. geom_text(): usado quando em vez de desenhar pontos nas coordenadas, desenhar texto, seja palavras ou letras. geom_polygon(): gera polígonos preenchidos onde cada vértice é uma linha no dataframe com as coordenadas de x e y em colunas separadas. É util para construção de mapas. geom_rect(), geom_tile() e geom_raster(): geram retângulos. Os parâmetros necessários para geom_rect() são as coordenadas máximas e mínimas das faces x e y sendo xmin, xmax, ymin e ymax. geom_tile() é exatamente o mesmo porém com x e y sendo as coordenadas do centro do retângulo e os parâmetros width e height como a largura e altura respectivamente. geom_raster() é usado caso o tamanho de todos os retângulos seja o mesmo para aumentar a velocidade da criação do gráfico. Cada um destes geoms será demonstrado nas figuras abaixo. Observe as semelhanças e diferenças dos eixos x e y, alguns extrapolam os valores estabelecidos pelos dados e podem estender os limítes dos eixos. df &lt;- data.frame ( x &lt;- c(1, 5, 9, 3.4), y &lt;- c(3, 6, 2, 5.4), label &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;) ) p &lt;- ggplot( df, aes(x, y, label = label)) + labs(x = NULL, y = NULL) + # esconde o nome dos eixos theme(plot.title = element_text(size = 12)) # diminui tamanho do texto p1 &lt;- p + geom_point() + ggtitle(&quot;ponto&quot;) p2 &lt;- p + geom_text() + ggtitle(&quot;texto&quot;) p3 &lt;- p + geom_bar(stat = &quot;identity&quot;) + ggtitle(&quot;barra&quot;) p4 &lt;- p + geom_tile() + ggtitle(&quot;raster&quot;) p1 + p2 + p3 + p4 p5 &lt;- p + geom_line() + ggtitle(&quot;linha&quot;) p6 &lt;- p + geom_area() + ggtitle(&quot;área&quot;) p7 &lt;- p + geom_path() + ggtitle(&quot;caminho&quot;) p8 &lt;- p + geom_polygon() + ggtitle(&quot;polígono&quot;) p5 + p6 + p7 + p8 5.5.2 Geoms coletivos Os geoms individuais criam objetos gráficos para cada observação ou linha da tabela contendo os dados, por exemplo, cada ponto de geom_point() representa uma linha de dados mas os geoms coletivos mostram várias observações, ou linhas, por elemento gráfico gerado. Isso pode ser o resultado de um resumo estatístico como um boxplot ou resultado de como os dados devem ser dispostos. Linhas e path estão no meio termo entre individuais e coletivos porque apesar de cada extremidade de uma linha ser apenas uma observação, o segmento é o conjunto de duas observações da tabela, ou seja, dois pontos. Para controlar o comportamento devemos usar a estética group. Por padrão, a estética group é mapeada para as variáveis discretas (ou categóricas) dos dados fornecidos à função ggplot() e na maioria dos casos o padrão é o suficiente para que os dados fiquem organizados no gráfico, porém quando não há variável discreta usada, é necessário que seja definido explicitamente um mapeamento agrupador dos dados. Há três casos comuns onde o padrão não é suficiente. Estes serão considerados abaixo. Para os exemplos a seguir será usado o dataset Oxboys do pacote nlme, que contém a altura e idade de 26 homens registrado em nove ocasiões diferentes. data(Oxboys, package = &quot;nlme&quot;) head(Oxboys) Grouped Data: height ~ age | Subject Subject age height Occasion 1 1 -1.0000 140.5 1 2 1 -0.7479 143.4 2 3 1 -0.4630 144.8 3 4 1 -0.1643 147.1 4 5 1 -0.0027 147.7 5 6 1 0.2466 150.2 6 5.5.2.1 Grupos múltiplos, uma estética Em várias situações é necessário separar os dados em grupos mas com a mesma estética. Em outras palavras: se deseja visualizar sujeitos distintos mas não é necessário identificá-los usando cores ou outros artifícios visuais. Isto é comum para estudos onde se quer ver a diferença entre vários sujeitos ao longo do tempo. Para exemplificar, abaixo na esquerda um plot com múltiplos grupos e uma estética e à direita múltiplos grupos e múltiplas estéticas: p1 &lt;- ggplot(Oxboys, aes(age, height, group = Subject)) + geom_point() + geom_line() + ggtitle(&quot;Uma estética&quot;) p2 &lt;- ggplot(Oxboys, aes(age, height, color = Subject)) + geom_point() + geom_line() + ggtitle(&quot;Múltiplas estéticas&quot;) p1 + p2 Neste caso o padrão de agrupamento não funciona e se não for definido explicitamente ou se for definido incorretamente o plot terá uma aparência de “lâmina de serra”. ggplot(Oxboys, aes(age, height)) + geom_point() + geom_line() Se um group não for definido por uma única variável e sim por combinação de várias é possível usar a função interaction() para combiná-las, por exemplo: aes(interaction(identidade_escola, identidade_aluno)). 5.5.2.2 Grupos em camadas diferentes Há vezes em que é necessário mostrar diferentes resumos estatísticos com agrupamentos específicos em camadas diferentes. Em uma camada pode mostrar valores não grupados enquanto que outra camada mostra um resumo estatístico agrupado. Reaproveitando o exemplo acima, deseja-se criar uma linha que demonstre o aumento da altura dos sujeitos ao longo do tempo. Abaixo na esquerda quando o mapeamento estético de group é feito no objeto principal, todas as camadas usam esta especificação para gerar a visualização, porém quando o mapeamento estético é especificado na camada específica, observa-se que apenas naquela camada o grupamento é feito. p1 &lt;- ggplot(Oxboys, aes(age, height, group = Subject)) + geom_line() + geom_smooth(method = &quot;lm&quot;, se = FALSE) + ggtitle(&quot;Grupo aplicado em \\ntodas as camadas&quot;) p2 &lt;- ggplot(Oxboys, aes(age, height)) + geom_line(aes(group = Subject)) + geom_smooth(method = &quot;lm&quot;, se = FALSE) + ggtitle(&quot;Grupo aplicado na \\ncamada line&quot;) p1 + p2 No lado direito, como o agrupamento foi feito na camada do geom_line() apenas estes dados estão agrupados enquanto que na camada geom_smooth() não foi feito nenhum agrupamento portanto a linha de regressão renderizada é em função de todos os dados. 5.5.2.3 Ignorando o grupamento padrão Alguns gráficos tem uma escala discreta no eixo x, porém ainda se deseja criar uma camada que conecte os grupos separados por essa escala discreta. Esta estratégia é usada para construção de interaction plots, profile plots e parallel coordinates plot. Um exemplo é quando usamos o dataset Oxboys para observar a distribuição da altura entre todos os sujeitos ao longo das ocasiões onde a altura foi medida. ggplot(Oxboys, aes(Occasion, height)) + geom_boxplot() A variável discreta deste gráfico é Occasion porém não especificamos ela como sendo uma variável agrupadora e nem precisamos, porque o ggplot2 entende que variáveis discretas devem ser tratados como grupamentos por padrão. Porém quando se deseja adicionar novas camadas com linhas de tendência ou outras visualizações este comportamento do ggplot2 pode não ser interessante por exemplo: quando tentamos adicionar linhas de tendência de aumento de altura as linhas geradas estão agrupadas pela variável Occasion resultando no gráfico abaixo: ggplot(Oxboys, aes(Occasion, height)) + geom_boxplot() + geom_line(colour = &quot;#6666FF&quot;, alpha = 0.5, size = 1.5) Para ignorar a variável agrupadora é necessario usar outra variável que agrupe os dados explícitamente como por exemplo abaixo: ggplot(Oxboys, aes(Occasion, height)) + geom_boxplot() + geom_line( aes(group = Subject), # Agrupamento explícito colour = &quot;#6666FF&quot;, alpha = 0.5, size = 1.5) 5.5.2.4 Ajustando estética a elementos gráficos Um importante fator de geoms coletivos é saber como que diferentes estéticas se comportam quando são mapeadas a um geom individual. No ggplot2 linhas e caminhos operam sob um princípio de “primeiro valor”, onde cada segmento é definido por duas observações e o ggplot2 aplica o mesmo valor estético (por exemplo: cor) associado à primeira observação que compõe o segmento. Isso significa que a estética usada na primeira observação é usada para desenhar o primeiro segmento e a estética da segunda observação será usada para desenhar o segundo segmento e assim em diante. Abaixo, exemplo visual deste efeito: df &lt;- data.frame(x = 1:4, y = 1:4, colour = c(1, 3, 5, 7)) p1 &lt;- ggplot(df, aes(x, y, colour = factor(colour))) + geom_line(aes(group = 1), size = 2) + geom_point(size = 5) p2 &lt;- ggplot(df, aes(x, y, colour = colour)) + geom_line(aes(group = 1), size = 2) + geom_point(size = 5) p1 + p2 Ao lado esquerdo, onde a cor é uma variável discreta (factor), o primeiro ponto e primeiro segmento são vermelhos, exemplificando o que foi dito anteriormente e ao lado direito, ocorre o mesmo mesmo se tendo uma variável contínua. Nota-se que não há um efeito de degradê entre as cores mesmo para variáveis contínuas, porém é possível atingir esta transição de cores fazendo a interpolação dos dados manualmente. # 100 pontos de interpolação xgrid &lt;- with(df, seq(min(x), max(x), length = 100)) # dataframe com dados interpolados interp &lt;- data.frame( x = xgrid, y = approx(df$x, df$y, xout = xgrid)$y, colour = approx(df$x, df$colour, xout = xgrid)$y ) ggplot(interp, aes(x, y, colour = colour)) + geom_line(size = 2) + geom_point(data = df, size = 5) Neste gráfico são criados vários segmentos de reta usando os dados do dataframe interp e os pontos usados são os mesmos do dataframe df usado nos gráficos anteriores. Outra limitação do ggplot2 é que linhas e caminhos devem tipo constante. Não é possível renderizar uma linha com tipo de linha variável. Outros geoms, como os coletivos são mais complicatos do que linhas e caminhos, e um elemento gráfico pode ser mapeado a várias observações. Nestes casos não é muito óbvio como as observações deveriam ser combinadas. Por exemplo: como colorir um polígono que tem pontos com cores diferentes em cada vértice? Devido a esse tipo de ambíguidade o ggplot2 adota uma regra única: “as estéticas de elementos individuais são apenas usadas se são todas iguais”. Se as estéticas dos elementos individuais são diferentes o ggplot2 usará um valor padrão. Estes problemas são mais relevantes quando mapeando estéticas à variáveis contínuas. Para variáveis discretas o comportamento padrão do ggplot2 é tratar a variável como parte da estética do grupo. O efeito é que o geom coletivo seja dividido em pedaços menores. Isto funciona muito bem para gráficos de barra e de área porque ao empilhar os pedaços individuais o formato fica igual aos dados não agrupados. p1 &lt;- ggplot(mpg, aes(class)) + geom_bar() p2 &lt;- ggplot(mpg, aes(class, fill = drv)) + geom_bar() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) p1 + p2 Se as estética fill for mapeada a uma variável contínua, não funciona e o grupamento padrão continua sendo class (eixo x). Para ter múltiplas cores por barra é necessário forçar o ggplot a ignorar o grupamento padrão através da definição explícita do grupamento. Exemplo abaixo: p1 &lt;- ggplot(mpg, aes(class, fill = hwy)) + geom_bar() p2 &lt;- ggplot(mpg, aes(class, fill = hwy, group = hwy)) + geom_bar() + scale_fill_viridis_c() p1 + p2 Acima à direita a aparência de transição de cores na verdade é apenas um grande número de pequenos grupos de uma variável discreta que geram esse efeito. 5.5.3 Resumos estatísticos 5.5.4 Resolvendo overplotting 5.5.5 Anotações Anotações "],
["tutoriais.html", "Aula 6 Tutoriais ", " Aula 6 Tutoriais "],
["regressões.html", "6.1 Regressões", " 6.1 Regressões Para criar modelos de regressão linear ou não linear no R precisamos usar uma tipo de objeto que tem a é da classe formula. Esta classe é usada em várias funções de base do R mas também no pacote de criação de gráficos ggplot2::. O que é essa classe formula: é um tipo de objeto que captura uma relacionamento simbólico entre variáveis, por exemplo: Tendo x como uma variável independente e y a variável dependente, para escrever \\(y\\) em função de \\(x\\) usamos a sytaxe y ~ x, onde o operador ~ separa as variáveis. Para modelos lineares esse é o mínimo que é necessário saber porém para mais informação sobre regressões com mais variáveis e modelos não lineares dê uma olhada neste link. 6.1.1 Regressões Lineares No R para criar modelos lineares simples é usada a função lm(). Os principais argumentos são a formula e os dasos (data), você pode ler os outros argumentos usando rodando ?lm() no console. Então para montar um modelo de regressão limples é apenas necessário ter um dataframe com uma coluna com os valores de x e uma coluna com os valores de y. Iremos usar os dados do dataset mpg para criar exemplos. fit &lt;- lm(cty ~ displ, data = mpg) print(fit) Call: lm(formula = cty ~ displ, data = mpg) Coefficients: (Intercept) displ 25.99 -2.63 class(fit) [1] &quot;lm&quot; O resultado obtidos são o coeficientes de Intercept que é o coeficiente linear da reta e o outro coeficiente que tem o nome da variável é o coeficiente angular da reta. A função print() mostra apenas estes valores mas podemos acessar mais valores do modelo usando outras funções ou métodos. Observamos também que a classe do objeto fit que foi criado é lm, portanto qualquer função que tenha como acessar os dados contidos em objetos de classe lm podem ser usadas, por exemplo summary() summary(fit) Call: lm(formula = cty ~ displ, data = mpg) Residuals: Min 1Q Median 3Q Max -6.3109 -1.4695 -0.2566 1.1087 14.0064 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 25.9915 0.4821 53.91 &lt;2e-16 *** displ -2.6305 0.1302 -20.20 &lt;2e-16 *** --- Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Residual standard error: 2.567 on 232 degrees of freedom Multiple R-squared: 0.6376, Adjusted R-squared: 0.6361 F-statistic: 408.2 on 1 and 232 DF, p-value: &lt; 2.2e-16 Usando a função summary() obtemos vários valores que podem não ter muito significado quando o interesse é verificar o coeficiente de determinação (\\(R^2\\)) de um modelo, inclusive a função summary() retorna este valor mas também dados sobre a distribuição de residuais, erro dos coeficientes e outros valores estatísticos. Inclusive podemos visualizar estes dados usando a função plot() de base que consegue gerar vários gráficos apenas com o objeto de classe lm. plot(fit) Porém para o uso em questão isso não é extremamente relevante porque não estamos buscando avaliar a normalidade da distribuição e sim verificar se o modelo é adequado para uma curva de calibração. Neste caso iremos gerar dados simulados para calcular um novo modelo: # concentração de 0 a 20 conc &lt;- 0:20 # absorbância é igual a 2x a concentração mais um valor entre 0,5 e 1 abs = 2 * conc + runif(n = length(conc), min = 0.5, max = 2) calibracao &lt;- data.frame(conc, abs) calibracao conc abs 1 0 0.8590273 2 1 3.1208056 3 2 5.5826276 4 3 7.7195992 5 4 9.3251839 6 5 11.5302078 7 6 13.6331478 8 7 14.5451210 9 8 16.9660726 10 9 19.7631313 11 10 21.5004752 12 11 23.6058041 13 12 25.0023234 14 13 27.3144653 15 14 28.9900946 16 15 31.7119190 17 16 32.5973771 18 17 35.5625801 19 18 37.7439302 20 19 38.5770344 21 20 41.8522225 Com os dados gerados podemos gerar o modelo linear para os dados de calibracao. fit_calib &lt;- lm(abs ~ conc, data = calibracao) summary(fit_calib) Call: lm(formula = abs ~ conc, data = calibracao) Residuals: Min 1Q Median 3Q Max -0.7590 -0.3270 0.1908 0.3309 0.5241 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 1.29121 0.18374 7.027 1.09e-06 *** conc 2.00185 0.01572 127.368 &lt; 2e-16 *** --- Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Residual standard error: 0.4361 on 19 degrees of freedom Multiple R-squared: 0.9988, Adjusted R-squared: 0.9988 F-statistic: 1.622e+04 on 1 and 19 DF, p-value: &lt; 2.2e-16 Como esperado, o coeficiente angular é de aproximadamente 2 e o coeficiente linear que deveria ser 0 é de 1.2912062. Como todos os objetos, o objeto da classe lm possui uma estrutura. Podemos ver esta estrutura usando a função str(), que retorna a estrutura completa dos objetos, porém de uma forma não muito fácil de entender str(fit_calib) List of 12 $ coefficients : Named num [1:2] 1.29 2 ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;(Intercept)&quot; &quot;conc&quot; $ residuals : Named num [1:21] -0.4322 -0.1722 0.2877 0.4229 0.0266 ... ..- attr(*, &quot;names&quot;)= chr [1:21] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... $ effects : Named num [1:21] -97.653 55.549 0.382 0.514 0.115 ... ..- attr(*, &quot;names&quot;)= chr [1:21] &quot;(Intercept)&quot; &quot;conc&quot; &quot;&quot; &quot;&quot; ... $ rank : int 2 $ fitted.values: Named num [1:21] 1.29 3.29 5.29 7.3 9.3 ... ..- attr(*, &quot;names&quot;)= chr [1:21] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... $ assign : int [1:2] 0 1 $ qr :List of 5 ..$ qr : num [1:21, 1:2] -4.583 0.218 0.218 0.218 0.218 ... .. ..- attr(*, &quot;dimnames&quot;)=List of 2 .. .. ..$ : chr [1:21] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... .. .. ..$ : chr [1:2] &quot;(Intercept)&quot; &quot;conc&quot; .. ..- attr(*, &quot;assign&quot;)= int [1:2] 0 1 ..$ qraux: num [1:2] 1.22 1.26 ..$ pivot: int [1:2] 1 2 ..$ tol : num 1e-07 ..$ rank : int 2 ..- attr(*, &quot;class&quot;)= chr &quot;qr&quot; $ df.residual : int 19 $ xlevels : Named list() $ call : language lm(formula = abs ~ conc, data = calibracao) $ terms :Classes &#39;terms&#39;, &#39;formula&#39; language abs ~ conc .. ..- attr(*, &quot;variables&quot;)= language list(abs, conc) .. ..- attr(*, &quot;factors&quot;)= int [1:2, 1] 0 1 .. .. ..- attr(*, &quot;dimnames&quot;)=List of 2 .. .. .. ..$ : chr [1:2] &quot;abs&quot; &quot;conc&quot; .. .. .. ..$ : chr &quot;conc&quot; .. ..- attr(*, &quot;term.labels&quot;)= chr &quot;conc&quot; .. ..- attr(*, &quot;order&quot;)= int 1 .. ..- attr(*, &quot;intercept&quot;)= int 1 .. ..- attr(*, &quot;response&quot;)= int 1 .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: R_GlobalEnv&gt; .. ..- attr(*, &quot;predvars&quot;)= language list(abs, conc) .. ..- attr(*, &quot;dataClasses&quot;)= Named chr [1:2] &quot;numeric&quot; &quot;numeric&quot; .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;abs&quot; &quot;conc&quot; $ model :&#39;data.frame&#39;: 21 obs. of 2 variables: ..$ abs : num [1:21] 0.859 3.121 5.583 7.72 9.325 ... ..$ conc: int [1:21] 0 1 2 3 4 5 6 7 8 9 ... ..- attr(*, &quot;terms&quot;)=Classes &#39;terms&#39;, &#39;formula&#39; language abs ~ conc .. .. ..- attr(*, &quot;variables&quot;)= language list(abs, conc) .. .. ..- attr(*, &quot;factors&quot;)= int [1:2, 1] 0 1 .. .. .. ..- attr(*, &quot;dimnames&quot;)=List of 2 .. .. .. .. ..$ : chr [1:2] &quot;abs&quot; &quot;conc&quot; .. .. .. .. ..$ : chr &quot;conc&quot; .. .. ..- attr(*, &quot;term.labels&quot;)= chr &quot;conc&quot; .. .. ..- attr(*, &quot;order&quot;)= int 1 .. .. ..- attr(*, &quot;intercept&quot;)= int 1 .. .. ..- attr(*, &quot;response&quot;)= int 1 .. .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: R_GlobalEnv&gt; .. .. ..- attr(*, &quot;predvars&quot;)= language list(abs, conc) .. .. ..- attr(*, &quot;dataClasses&quot;)= Named chr [1:2] &quot;numeric&quot; &quot;numeric&quot; .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;abs&quot; &quot;conc&quot; - attr(*, &quot;class&quot;)= chr &quot;lm&quot; Mas o que podemos observar é que o objeto é uma lista com 12 elementos então podemos acessar estes elementos através de seus índices ou de seus nomes. # coeficientes fit_calib$coefficients (Intercept) conc 1.291206 2.001847 # residuais fit_calib$residuals 1 2 3 4 5 6 7 -0.4321789086 -0.1722473353 0.2877279188 0.4228527583 0.0265906615 0.2297677837 0.3308610706 8 9 10 11 12 13 14 -0.7590124785 -0.3399077223 0.4553042355 0.1908013853 0.2942835694 -0.3110439584 -0.0007488059 15 16 17 18 19 20 21 -0.3269662433 0.3930114151 -0.7233772708 0.2399788961 0.4194822465 -0.7492602983 0.5240810807 E para acessar elementos específicos destas listas usamos os operadores [ ] # coeficiente linear (intercept) fit_calib$coefficients[1] (Intercept) 1.291206 # coeficiente angular fit_calib$coefficients[2] conc 2.001847 # valor do coeficiente linear (intercept) fit_calib$coefficients[[1]] [1] 1.291206 # valor do coeficiente angular fit_calib$coefficients[[2]] [1] 2.001847 # R quadrado summary(fit_calib)$r.squared [1] 0.9988302 Claro que parece muito complicado ter que fazer tudo isso para extrair alguns dados e mesmo assim, existem várias formas de extraí-los o que causa muita confusão, portanto iremos explorar alguns métodos para extraír estes dados do objeto lm(). 6.1.1.1 Método de função É fundamental em qualquer linguagem de programação que se saiba escrever funções que facilitem seu trabalho e deixem o código mais simples. Neste documento não estão escritas necessariamente as melhores funções que são mais eficientes mas aquelas que funcionam para o que é desejado. Na grande maioria das vezes é melhor escrever uma função rápido do que escrever uma função que funcione rápido. Otimização de código não é a nossa prioridade agora. Em outro capítulo será explorado a criação de funções melhor mas agora iremos apenas usar lógica para criar uma função que extraia os dados de coeficiente linear, angular, e \\(R^2\\) e coloque-os em um dataframe com os nomes e os valores usando a sintaxe já demonstrada. extrair &lt;- function(fit) { #fit é o argumento desta função # cria variável que contém coeficiente linear coef_lin &lt;- fit$coefficients[[1]] # cria variável que contém coeficiente angular coef_ang &lt;- fit$coefficients[[2]] # cria variável que contém r quadrado r_quadrado &lt;- summary(fit)$r.squared # cria dataframe com os dados em cada coluna tabela &lt;- data.frame( &quot;Coeficiente Linear&quot; = coef_lin, &quot;Coeficiente Angular&quot; = coef_ang, &quot;R quadrado&quot; = r_quadrado ) # pede para a função retornar o dataframe como output return(tabela) } # usando função nos dados de calibração extrair(fit_calib) Coeficiente.Linear Coeficiente.Angular R.quadrado 1 1.291206 2.001847 0.9988302 # usando função nos dados de mpg extrair(fit) Coeficiente.Linear Coeficiente.Angular R.quadrado 1 25.99147 -2.630482 0.6376405 Agora esta função pode ser usada sempe que se desejar extrair estes dados de um modelo linear criado com lm(). Não é a função mais robusta e alguns erros podem surgir quando tentando combinar ela com outras operações, mas para uma introdução funciona muito bem. 6.1.1.2 Método ggplot2 Um dos geoms do ggplot2 é o geom_smooth() que pode ser usado para plotar diversos modelos de regressão que não apenas lineares. É suplementado pela camada stat_smooth() que tem mais funcionalidade e mais customização. Para criar um gráfico com os pontos e a linha de regressão precisamos apenas dos dados de concentração e absorbância: ggplot(calibracao, aes( x = conc, y = abs )) + geom_point() + # method = lm indica que quero representar um modelo linear, # se = FALSE indica que não quero mostrar o erro padrão calculado geom_smooth(method = &quot;lm&quot;, se = FALSE, color = &quot;red&quot;, formula = &quot;y ~ x&quot;) Porém o ggplot2 não inclui nada que nos permita adicionar a equação com os coeficientes e o \\(R^2\\) automaticamente portanto temos que adicionar individualmente usando os dados extraídos com a nossa função extrair(). coefs &lt;- extrair(fit = fit_calib) coefs Coeficiente.Linear Coeficiente.Angular R.quadrado 1 1.291206 2.001847 0.9988302 ggplot(calibracao, aes( x = conc, y = abs )) + geom_smooth(method = &quot;lm&quot;, se = FALSE, color = &quot;red&quot;, formula = &quot;y ~ x&quot;) + geom_point() + annotate(geom = &quot;text&quot;, x = 5, # posição no eixo x y = 40, # posição no eixo y label = paste0(&quot;y = &quot;, coefs$Coeficiente.Angular, &quot;x + &quot;, coefs$Coeficiente.Linear)) + annotate(geom = &quot;text&quot;, x = 5, # posição no eixo x y = 36, # posição no eixo y label = paste0(&quot;R quadrado = &quot;, coefs$R.quadrado)) Claro que agora temos um problema de números significativos em excesso e de formatação da equação e do \\(R^2\\). Para resolver isso temos que usar a função format()para reduzir o número de dígitos significativos ou round() para arredondar e o argumento parse == TRUE para forçar o sobrescrito na camada de anotação. ggplot(calibracao, aes( x = conc, y = abs )) + geom_smooth(method = &quot;lm&quot;, se = FALSE, color = &quot;red&quot;, formula = &quot;y ~ x&quot;) + geom_point() + annotate(geom = &quot;text&quot;, x = 5, # posição no eixo x y = 40, # posição no eixo y label = paste0(&quot;y = &quot;, round(coefs$Coeficiente.Angular, digits = 3), &quot;x + &quot;, format(coefs$Coeficiente.Linear, digits = 2))) + annotate(geom = &quot;text&quot;, x = 5, # posição no eixo x y = 36, # posição no eixo y label = paste0(&quot;R^2 ==&quot;, round(coefs$R.quadrado, digits = 4)) , parse = TRUE) # força a renderização do texto como uma expressão matemática Claro que podemos escrever uma função usando as funções do ggplot para simplificar a construção destes gráficos, e esta pode ser uma alternativa viável mas outras pessoas já fizeram isso e publicaram pacotes justamente para atender esta necessidade. 6.1.1.3 Método ggpmisc O pacote ggpmisc é uma extensão do ggplot que adiciona funcionalidades sobre o mesmo. Com ele adicionar a equação e os coeficientes se torna muito mais simples. library(ggpmisc) News about &#39;ggpmisc&#39; at https://www.r4photobiology.info/ ggplot(calibracao, aes( x = conc, y = abs )) + geom_smooth(method = &quot;lm&quot;, formula = &quot;y ~ x&quot;, se = FALSE, color = &quot;red&quot;) + geom_point() + # retirado da página do criador do pacote # https://github.com/cran/ggpmisc stat_poly_eq(aes(label = paste(..eq.label.., ..adj.rr.label.., sep = &quot;~~~~&quot;)), formula = &quot;y~x&quot;, parse = TRUE) Admito que não sei usar as funções deste pacote então recomendo que quem estiver lendo estas informaçõs busque outras fontes de conteúdo. A página do desenvolvedor contém várias informações e exemplos. 6.1.1.4 Método ggpubr Provavelmente este é o método mais simples para gerar gráficos de regressão linear para uma curva de calibração. O pacote é outra extensão do ggplot2 e foi feito para facilitar a construção de plots comuns no meio científico. A página possui vários exemplos e a documentação necessária para criação dos gráficos. O ggpubr é uma ferramenta que facilita bastante o uso do R para construção de gráficos, porém com algumas desvantagens e limitaçòes de customização. A sintaxe é um pouco diferente do ggplot mas similar o suficiente para não criar uma barreira para o usuário. library(ggpubr) ggpubr &lt;- ggscatter(calibracao, x = &quot;conc&quot;, y = &quot;abs&quot;, add = &quot;reg.line&quot;) + stat_cor(label.x = 5, label.y = 36) + stat_regline_equation(label.x = 5, label.y = 40) + ggtitle(&quot;Criado com ggpubr&quot;) ggpubr Alternativamente as funções do ggpubr podem ser usadas em plots criados com o ggplot2 porque os objetos criados pelos dois tem compatibilidades. gg &lt;- ggplot(calibracao, aes( x = conc, y = abs )) + geom_smooth(method = &quot;lm&quot;, se = FALSE, color = &quot;red&quot;, formula = &quot;y ~ x&quot;) + geom_point() + stat_cor(label.x = 5, label.y = 36) + stat_regline_equation(label.x = 5, label.y = 40) + ggtitle(&quot;Criado com ggplot2 + ggpubr&quot;) # usando patchwork ggpubr + gg Existe uma infinidade de formas de mostrar estes dados, o importante é achar a forma que melhor atende suas necessidades e que seja o mais fácil criar. "],
["smoothing.html", "6.2 Smoothing", " 6.2 Smoothing Smoothing é uma operação usada tanto para diminuir ruído de dados obtidos experimentalmente quanto para buscar observar tendências gerais do relacionamento entre variáveis. Em geral para suavizar os dados é usado o método de moving average, também chamado de rolling average onde é calculada a média de pontos adjacentes para que o ruído dos dados fique menos proeminente. No R, através das funções do ggplot2 pode ser usado o geom_smooth() para se obter curvas com perfil “suavizado”, ou smoothed. Vamos usar o exemplo de uma análise de difração de raios x. # lê os dados no arquivo DRX.txt na pasta dados df &lt;- read_table(&quot;dados/DRX.txt&quot;, # pula as 30 primeiras linhas do arquivo que contém informações não necessárias skip = 30) %&gt;% # seleciona colunas &lt;2Theta&gt; e &lt;I&gt; e as renomeia select(&quot;theta_2&quot; = `&lt;2Theta&gt;`, &quot;I&quot; = `I &gt;`) Parsed with column specification: cols( `&lt;2Theta&gt;` = col_double(), `&lt;` = col_logical(), `I &gt;` = col_double() ) Primeiro importamos os dados usando a função read_table(). O argumento skip = 30 serve para indicar que as 30 primeiras linhas do arquivo devem ser ignoradas porque não contém os dados de interesse e sim outras informações da amostra e da análise. A função select() é usada para selecionar apenas as colunas de interesse e simultaneamente renomear as coluna selecionadas. obs. No arquivo de texto original as colunas estão separadas por espaços em branco e por isso se usa a função read_table() porém para a coluna de intensidade (&lt;I&gt;) há espaçoes desnecessários entre o &lt; e I, o que causa a má interpretação do texto portanto foi necessário especificar o nome da coluna exatamente como foi lido pela função read_table(). Agora para fazer o gráfico usamos o ggplot2: p &lt;- ggplot(df, aes( x = theta_2, y = I ) ) + geom_line() + theme_bw() p + geom_smooth(method = &quot;loess&quot;, span = 0.01, se = FALSE) O método loess significa que o calculo feito é uma regressão local entre a fração de pontos especificada pelo argumento span. Quanto menor o span maior será a “resolução” da curva suavizada. Abaixo a comparação: span1 &lt;- p + geom_smooth(method = &quot;loess&quot;, span = 1, se = FALSE) + ggtitle(&quot;Span = 1&quot;) span05 &lt;- p + geom_smooth(method = &quot;loess&quot;, span = 0.5, se = FALSE) + ggtitle(&quot;Span = 0.5&quot;) span01 &lt;- p + geom_smooth(method = &quot;loess&quot;, span = 0.1, se = FALSE) + ggtitle(&quot;Span = 0.1&quot;) span1 + span05 + span01 Mesmo assim com esse span pequeno perde-se muito a resolução dos dados então a melhor solução é usar o pacote tidyquant que tem um geom específico para criar gráficos com moving average. O geom que o pacote tidyquant providencia é um geom que gera os dados do moving average direto no gráfico, sem necessidade de modificar os dados originais. O principal argumento que o geom_ma() usa neste caso é o n. n é o número de pontos adjacentes que serão usados para calcular a média, logo quanto maior o n mais suave será a curva. O efeito colateral esperado é que os picos percam um pouco de definição porém o resultado é muito melhor do que o que o geom_smooth() gera. Abaixo a comparação: library(tidyquant) span001 &lt;- p + geom_smooth(method = &quot;loess&quot;, span = 0.01, se = FALSE) + ggtitle(&quot;Span = 0.01&quot;) n5 &lt;- p + geom_ma(n = 5, linetype = &quot;solid&quot;, size = 1) + ggtitle(&quot;n = 5&quot;) n10 &lt;- p + geom_ma(n = 10, linetype = &quot;solid&quot;, size = 1) + ggtitle(&quot;n = 10&quot;) span001 + n5 + n10 Outra forma de fazer o mesmo seria criar um novo dataframe com os dados da mobing average e plotá-los usando os geoms do ggplot depende do usuário definir qual a melhor forma de tratar os dados. "],
["references.html", "References", " References Chambers, John M, William S Cleveland, Beat Kleiner, and Paul A Tukey. 1983. “Graphical Methods for Data Analysis. Wadsworth &amp; Brooks.” Cole Statistics/Probability Series. Wickham, Hadley. 2014. “Tidy Data.” Journal of Statistical Software, Articles 59 (10): 1–23. https://doi.org/10.18637/jss.v059.i10. "]
]
