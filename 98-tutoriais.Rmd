# Tutoriais

## Regressões

Para criar modelos de regressão linear ou não linear no `R` precisamos usar uma tipo de objeto que tem a é da classe `formula`.
Esta classe é usada em várias funções de base do `R` mas também no pacote de criação de gráficos `ggplot2::`.
O que é essa classe `formula`: é um tipo de objeto que captura uma relacionamento simbólico entre variáveis, por exemplo:

- Tendo `x` como uma variável independente e `y` a variável dependente, para escrever $y$ em função de $x$ usamos a sytaxe `y ~ x`,
onde o operador `~` separa as variáveis.

Para modelos lineares esse é o mínimo que é necessário saber porém para mais informação sobre regressões com mais variáveis e modelos não lineares dê uma olhada neste [link](https://www.datacamp.com/community/tutorials/r-formula-tutorial#datastructures).

### Regressões Lineares

No `R` para criar modelos lineares simples é usada a função `lm()`.
Os principais argumentos são a `formula` e os dasos (`data`), você pode ler os outros argumentos usando rodando `?lm()` no console.
Então para montar um modelo de regressão limples é apenas necessário ter um dataframe com uma coluna com os valores de `x` e uma coluna com os valores de `y`.
Iremos usar os dados do dataset `mpg` para criar exemplos.

```{r}

fit <- lm(cty ~ displ, data = mpg)

print(fit)

class(fit)

```

O resultado obtidos são o coeficientes de *Intercept* que é o coeficiente linear da reta e o outro coeficiente que tem o nome da variável é o coeficiente angular da reta.
A função `print()` mostra apenas estes valores mas podemos acessar mais valores do modelo usando outras funções ou métodos.

Observamos também que a classe do objeto `fit` que foi criado é `lm`, portanto qualquer função que tenha como acessar os dados contidos em objetos de classe `lm` podem ser usadas, por exemplo `summary()`

```{r}

summary(fit)

```

Usando a função `summary()` obtemos vários valores que podem não ter muito significado quando o interesse é verificar o coeficiente de determinação ($R^2$) de um modelo, inclusive a função `summary()` retorna este valor mas também dados sobre a distribuição de residuais, erro dos coeficientes e outros valores estatísticos.
Inclusive podemos visualizar estes dados usando a função `plot()` de base que consegue gerar vários gráficos apenas com o objeto de classe `lm`.

```{r}

plot(fit)

```

Porém para o uso em questão isso não é extremamente relevante porque não estamos buscando avaliar a normalidade da distribuição e sim verificar se o modelo é adequado para uma curva de calibração.

Neste caso iremos gerar dados simulados para calcular um novo modelo:

```{r}

# concentração de 0 a 20
conc <- 0:20 

# absorbância é igual a 2x a concentração mais um valor entre 0,5 e 1
abs  = 2 * conc + runif(n = length(conc), min = 0.5, max = 2)

calibracao <- data.frame(conc, abs)

calibracao

```

Com os dados gerados podemos gerar o modelo linear para os dados de `calibracao`.

```{r}

fit_calib <- lm(abs ~ conc, data = calibracao)

summary(fit_calib)
```

Como esperado, o coeficiente angular é de aproximadamente 2 e o coeficiente linear que deveria ser 0 é de `r fit_calib$coefficients[[1]]`.
Como todos os objetos, o objeto da classe `lm` possui uma estrutura.
Podemos ver esta estrutura usando a função `str()`, que retorna a estrutura completa dos objetos, porém de uma forma não muito fácil de entender 

```{r}

str(fit_calib)

```

Mas o que podemos observar é que o objeto é uma lista com 12 elementos então podemos acessar estes elementos através de seus índices ou de seus nomes.

```{r}

# coeficientes
fit_calib$coefficients

# residuais
fit_calib$residuals

```

E para acessar elementos específicos destas listas usamos os operadores `[ ]`

```{r}

# coeficiente linear (intercept)
fit_calib$coefficients[1]

# coeficiente angular
fit_calib$coefficients[2]

# valor do coeficiente linear (intercept)
fit_calib$coefficients[[1]]

# valor do coeficiente angular
fit_calib$coefficients[[2]]

# R quadrado
summary(fit_calib)$r.squared

```

Claro que parece muito complicado ter que fazer tudo isso para extrair alguns dados e mesmo assim, existem várias formas de extraí-los o que causa muita confusão, portanto iremos explorar alguns métodos para extraír estes dados do objeto `lm()`.

#### Método de função

É fundamental em qualquer linguagem de programação que se saiba escrever funções que facilitem seu trabalho e deixem o código mais simples.
Neste documento não estão escritas necessariamente as melhores funções que são mais eficientes mas aquelas que funcionam para o que é desejado. Na grande maioria das vezes é melhor escrever uma função rápido do que escrever uma função que funcione rápido.
Otimização de código não é a nossa prioridade agora.

Em outro capítulo será explorado a criação de funções melhor mas agora iremos apenas usar lógica para criar uma função que extraia os dados de coeficiente linear, angular, e $R^2$ e coloque-os em um dataframe com os nomes e os valores usando a sintaxe já demonstrada.

```{r funcao-extrair}

extrair <- function(fit) { #fit é o argumento desta função
	
	# cria variável que contém coeficiente linear
	coef_lin <- fit$coefficients[[1]]
	# cria variável que contém coeficiente angular
	coef_ang <- fit$coefficients[[2]]
	# cria variável que contém r quadrado
	r_quadrado <- summary(fit)$r.squared
	
	# cria dataframe com os dados em cada coluna
	tabela <- data.frame(
		"Coeficiente Linear" = coef_lin,
		"Coeficiente Angular" = coef_ang,
		"R quadrado" = r_quadrado
		)
	
	# pede para a função retornar o dataframe como output
	return(tabela)
	
}

# usando função nos dados de calibração
extrair(fit_calib)

# usando função nos dados de mpg
extrair(fit)
```

Agora esta função pode ser usada sempe que se desejar extrair estes dados de um modelo linear criado com `lm()`.
Não é a função mais robusta e alguns erros podem surgir quando tentando combinar ela com outras operações, mas para uma introdução funciona muito bem.

#### Método `ggplot2`

Um dos `geom`s do ggplot2 é o `geom_smooth()` que pode ser usado para plotar diversos modelos de regressão que não apenas lineares.
É suplementado pela camada `stat_smooth()` que tem mais funcionalidade e mais customização.
Para criar um gráfico com os pontos e a linha de regressão precisamos apenas dos dados de concentração e absorbância:

```{r}

ggplot(calibracao,
			 aes(
			 	x = conc,
			 	y = abs
			 )) +
	geom_point() +
	# method = lm indica que quero representar um modelo linear,
	# se = FALSE indica que não quero mostrar o erro padrão calculado
	geom_smooth(method = "lm", se = FALSE, color = "red", formula = "y ~ x")

```

Porém o `ggplot2` não inclui nada que nos permita adicionar a equação com os coeficientes e o $R^2$ automaticamente portanto temos que adicionar individualmente usando os dados extraídos com a nossa função `extrair()`.

```{r}

coefs <- extrair(fit = fit_calib)
coefs

ggplot(calibracao,
			 aes(
			 	x = conc,
			 	y = abs
			 )) +
	geom_smooth(method = "lm", se = FALSE, color = "red", formula = "y ~ x") +
	geom_point() +
	annotate(geom = "text",
					 x = 5, # posição no eixo x 
					 y = 40, # posição no eixo y
					 label = paste0("y = ", coefs$Coeficiente.Angular, "x + ", coefs$Coeficiente.Linear)) +
	annotate(geom = "text",
					 x = 5, # posição no eixo x 
					 y = 36, # posição no eixo y
					 label = paste0("R quadrado = ", coefs$R.quadrado))

```

Claro que agora temos um problema de números significativos em excesso e de formatação da equação e do $R^2$.
Para resolver isso temos que usar a função `format()`para reduzir o número de dígitos significativos ou `round()` para arredondar e o argumento `parse == TRUE` para forçar o sobrescrito na camada de anotação.

```{r}
ggplot(calibracao,
			 aes(
			 	x = conc,
			 	y = abs
			 )) +
	geom_smooth(method = "lm", se = FALSE, color = "red", formula = "y ~ x") +
	geom_point() +
	annotate(geom = "text",
					 x = 5, # posição no eixo x 
					 y = 40, # posição no eixo y
					 label = paste0("y = ", round(coefs$Coeficiente.Angular, digits = 3), "x + ", format(coefs$Coeficiente.Linear, digits = 2))) +
	annotate(geom = "text",
					 x = 5, # posição no eixo x 
					 y = 36, # posição no eixo y
					 label = paste0("R^2 ==", round(coefs$R.quadrado, digits = 4)) ,
					 parse = TRUE) # força a renderização do texto como uma expressão matemática
```

Claro que podemos escrever uma função usando as funções do `ggplot` para simplificar a construção destes gráficos, e esta pode ser uma alternativa viável mas outras pessoas já fizeram isso e publicaram pacotes justamente para atender esta necessidade.

#### Método `ggpmisc`

O pacote `ggpmisc` é uma extensão do `ggplot` que adiciona funcionalidades sobre o mesmo.
Com ele adicionar a equação e os coeficientes se torna muito mais simples.

```{r}
library(ggpmisc)

ggplot(calibracao,
			 aes(
			 	x = conc,
			 	y = abs
			 )) +
	geom_smooth(method = "lm", formula = "y ~ x", se = FALSE, color = "red") + 
	geom_point() +
	# retirado da página do criador do pacote
	# https://github.com/cran/ggpmisc
  stat_poly_eq(aes(label =  paste(..eq.label.., ..adj.rr.label.., sep = "~~~~")),
               formula = "y~x", parse = TRUE)

```

Admito que não sei usar as funções deste pacote então recomendo que quem estiver lendo estas informaçõs busque outras fontes de conteúdo.
A [página](https://github.com/cran/ggpmisc) do desenvolvedor contém várias informações e exemplos.

#### Método `ggpubr`

Provavelmente este é o método mais simples para gerar gráficos de regressão linear para uma curva de calibração.
O pacote é outra extensão do `ggplot2` e foi feito para facilitar a construção de *plots* comuns no meio científico.
A [página](https://rpkgs.datanovia.com/ggpubr/index.html) possui vários exemplos e a documentação necessária para criação dos gráficos.

O `ggpubr` é uma ferramenta que facilita bastante o uso do `R` para construção de gráficos, porém com algumas desvantagens e limitaçòes de customização.
A sintaxe é um pouco diferente do `ggplot` mas similar o suficiente para não criar uma barreira para o usuário.

```{r message=FALSE, warning=FALSE}
library(ggpubr)

ggpubr <- ggscatter(calibracao,
					x = "conc",
					y = "abs",
					add = "reg.line") +
	stat_cor(label.x = 5, label.y = 36) + 
	stat_regline_equation(label.x = 5, label.y = 40) +
	ggtitle("Criado com ggpubr")

ggpubr
```

Alternativamente as funções do `ggpubr` podem ser usadas em *plots* criados com o `ggplot2` porque os objetos criados pelos dois tem compatibilidades.

```{r}

gg <- ggplot(calibracao,
			 aes(
			 	x = conc,
			 	y = abs
			 )) +
	geom_smooth(method = "lm", se = FALSE, color = "red", formula = "y ~ x") +
	geom_point() +
	stat_cor(label.x = 5, label.y = 36) + 
	stat_regline_equation(label.x = 5, label.y = 40) +
	ggtitle("Criado com ggplot2 + ggpubr")


# usando patchwork
ggpubr + gg

```

Existe uma infinidade de formas de mostrar estes dados, o importante é achar a forma que melhor atende suas necessidades e que seja o mais fácil criar.

***

## Smoothing

Smoothing é uma operação usada tanto para diminuir ruído de dados obtidos experimentalmente quanto para buscar observar tendências gerais do relacionamento entre variáveis.

Em geral para suavizar os dados é usado o método de *moving average*, também chamado de *rolling average* onde é calculada a média de pontos adjacentes para que o ruído dos dados fique menos proeminente.

No `R`, através das funções do `ggplot2` pode ser usado o `geom_smooth()` para se obter curvas com perfil "suavizado", ou smoothed.
Vamos usar o exemplo de uma análise de difração de raios x.

```{r DRX-data}

# lê os dados no arquivo DRX.txt na pasta dados
df <- read_table("dados/DRX.txt", 
# pula as 30 primeiras linhas do arquivo que contém informações não necessárias
								 skip = 30) %>% 
# seleciona colunas <2Theta> e <I> e as renomeia
	select("theta_2" = `<2Theta>`, "I" = `I   >`)

```

- Primeiro importamos os dados usando a função `read_table()`.
- O argumento `skip = 30` serve para indicar que as 30 primeiras linhas do arquivo devem ser ignoradas porque não contém os dados de interesse e sim outras informações da amostra e da análise.
- A função `select()` é usada para selecionar apenas as colunas de interesse e simultaneamente renomear as coluna selecionadas.

> obs. No arquivo de texto original as colunas estão separadas por espaços em branco e por isso se usa a função `read_table()` porém para a coluna de intensidade (`<I>`) há espaçoes desnecessários entre o `<` e `I`, o que causa a má interpretação do texto portanto foi necessário especificar o nome da coluna exatamente como foi lido pela função `read_table()`.

Agora para fazer o gráfico usamos o `ggplot2`:

```{r drx-ggplot}

p <- ggplot(df,
			 aes(
			 	x = theta_2,
			 	y = I
			 )
			) +
	geom_line() +
	theme_bw() 
	

p + geom_smooth(method = "loess", span = 0.01, se = FALSE) 

```

O método `loess` significa que o calculo feito é uma regressão local entre a fração de pontos especificada pelo argumento `span`.
Quanto menor o `span` maior será a "resolução" da curva suavizada.
Abaixo a comparação:

```{r span-span1}
span1 <- p + geom_smooth(method = "loess", span = 1, se = FALSE) +
	ggtitle("Span = 1")
span05 <- p + geom_smooth(method = "loess", span = 0.5, se = FALSE) +
	ggtitle("Span = 0.5")
span01 <- p + geom_smooth(method = "loess", span = 0.1, se = FALSE) +
	ggtitle("Span = 0.1")


span1 + span05 + span01
```

Mesmo assim com esse `span` pequeno perde-se muito a resolução dos dados então a melhor solução é usar o pacote `tidyquant` que tem um geom específico para criar gráficos com *moving average*.

O geom que o pacote `tidyquant` providencia é um geom que gera os dados do *moving average* direto no gráfico, sem necessidade de modificar os dados originais.
O principal argumento que o `geom_ma()` usa neste caso é o `n`.
`n` é o número de pontos adjacentes que serão usados para calcular a média, logo quanto maior o `n` mais suave será a curva.
O efeito colateral esperado é que os picos percam um pouco de definição porém o resultado é muito melhor do que o que o `geom_smooth()` gera.
Abaixo a comparação:

```{r}
library(tidyquant)

span001 <- p + geom_smooth(method = "loess", span = 0.01, se = FALSE) +
	ggtitle("Span = 0.01")
n5 <- p + geom_ma(n = 5, linetype = "solid", size = 1) +
	ggtitle("n = 5")
n10 <- p + geom_ma(n = 10, linetype = "solid", size = 1) +
	ggtitle("n = 10")

span001 + n5 + n10

```

Outra forma de fazer o mesmo seria criar um novo dataframe com os dados da *mobing average* e plotá-los usando os geoms do `ggplot` depende do usuário definir qual a melhor forma de tratar os dados.
